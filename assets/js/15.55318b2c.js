(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{422:function(n,t,e){"use strict";e.r(t);var a=e(2),r=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"html"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[n._v("#")]),n._v(" HTML")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("尚硅谷前端html+css零基础教程，2023最新前端html5+css3视频\nhttps://www.bilibili.com/video/BV1p84y1P7Z5?p=11&spm_id_from=pageDriver&vd_source=a8cfd293b041596809a049e5402434c3\n")])])]),t("h2",{attrs:{id:"架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[n._v("#")]),n._v(" 架构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("C/S（Client-Server）客户端和服务器结构\nB/S（Browser-Server）浏览器和服务器架构\n客户端 ---\x3e 服务器 <---\x3e数据库\n\nstatcounter官网可以查阅搜索引擎等份额\n")])])]),t("h2",{attrs:{id:"_5大浏览器四大内核"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5大浏览器四大内核"}},[n._v("#")]),n._v(" 5大浏览器四大内核")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("chrome 早期webkit内核 现在blink内核\nsafari webkit内核\nIE: Trident内核\nfirefox:Gecko内核\nopera: Presto内核（放弃维护）,现在Blink内核\n")])])]),t("h2",{attrs:{id:"什么是网页"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是网页"}},[n._v("#")]),n._v(" 什么是网页")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("xxx.html 以html结尾的文件\n\n结构 html\n表现 css\n行为 javascript\n")])])]),t("h2",{attrs:{id:"html-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html-2"}},[n._v("#")]),n._v(" HTML")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Hyper Text Markup Language，即超文本标记语言\n\n")])])]),t("h2",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[n._v("#")]),n._v(" 语法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<标签名>标签体</标签名>\n<起始标签>标签体</结束标签>\nex.\n<marquee>hello world</marquee>\n\n注意：\n1.区分大小写，按照规范这边是小写\n2.并不是每一个标签，都是成对出现的\nex.\n<input>  //输入框\n\x3c!-- 注释内容 --\x3e   //注释的写法\n\n3.单标签\n<input> 可以写成 <input/>\n这是因为代码习惯\n不写也可以，因为单标签就那么几个\n\n4.标签可以嵌套\n\x3c!-- 想要输入框滚动 --\x3e\n<marquee>hello world<input></marquee>\n\n5.注意格式换行\n<marquee>\n\thello world\n\t<input>\n</marquee>\n\n6.一般把每个标签也成为元素element\n\n")])])]),t("h2",{attrs:{id:"对象和属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象和属性"}},[n._v("#")]),n._v(" 对象和属性")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("把每一个现实生活中的人物当做每一个对象\nex.\n一个人有名字，叫小王；会说话,会说我爱你 \n对应在编程里它便是\n一个人是一个对象,这个对象有“名字”这个属性，名字属性的值是“小王”,以及“说话”这个属性（一般动作类属性叫做方法），执行这个方法(一般不会说执行这个属性)，便会执行我爱你这个动作\n")])])]),t("h2",{attrs:{id:"标签属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标签属性"}},[n._v("#")]),n._v(" 标签属性")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<marquee loop="1" bgcolor="red">\n\thello world\n\t<input type="password" disabled>\n</marquee>\n\n以上效果是 只循环一次；背景颜色为红色\n\n释意\n1. marquee这个标签 有loop这属性\n2. = 是赋值符号 不是相等符号\n属性名 = 属性值： 把值赋值给属性 而不是相等\n3. 为什么这里能写loop 因为marquee这个标签，是内置标签（已经定义好了的标签，不是用户我自定义的标签），这个内置标签里已经定义好了很多属性，所以属性名等不能随便写\n怎么看能写什么，百度它的官网或者直接百度\n\n暂时理解到这里\n\n3. "" 表示字符串类型\n4. "1" 和 1 的区别在于 前者是字符串类型 后者是 数字类型\n5. loop = "1" 的意思是 把"1"(字符串的1) 赋值给 loop \n6. 为什么不是 loop = 1 是因为 loop这个属性 需要 字符串类型 而不是数字类型\n\n关键词： 属性 赋值 类型 值\n\n注意：\n不同标签有不同属性\n也有一些属性时通用的 之后总结，用多了就知道了\n\n')])])]),t("h2",{attrs:{id:"谷歌浏览器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#谷歌浏览器"}},[n._v("#")]),n._v(" 谷歌浏览器")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("会检查代码是否符合HTML格式, 大小写等\n如果符合，则直接渲染，显示\n如果不符合，会进行处理，再显示\n如果处理不成功，会报错\n")])])]),t("h2",{attrs:{id:"html文件-xxx-html网页-的基本结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html文件-xxx-html网页-的基本结构"}},[n._v("#")]),n._v(" HTML文件(xxx.html网页)的基本结构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('在test.html文件里写\n<marquee loop="1" bgcolor="red">\n\thello world\n\t<input type="password" disabled>\n</marquee>\n\n在谷歌浏览器里渲染的时候，变成以下结构\n如何查看F12 或 右键-查看 打开 开发辅助工具\n选择Elements\n\n<html>\n\t<head>\n\t\t\x3c!-- head标签的内容不会展示在网页中 --\x3e\n\n\t\t\x3c!-- 通过title标签，指定网页的标题 --\x3e\n\t\t<title>我的网页</title>\n\t</head>\n\t<body>\n\t\t\x3c!-- 展示区域 --\x3e\n\t\t<marquee loop="1" bgcolor="red">\n\t\t\thello world\n\t\t\t<input type="password" disabled>\n\t\t</marquee>\n\t</body>\n</html>\n\n<html>\n\t<head></head>\n\t<body>\n\t\t\n\t</body>\n</html>\n\n当然对于一个成熟的网站来说，谷歌自动帮忙添加的东西还远远不够\n\n\n')])])]),t("h2",{attrs:{id:"vscode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vscode"}},[n._v("#")]),n._v(" vscode")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("IDE 集成开发环境\n前端：vscode webstorm\n后端: Eclipse IDEA\n\n如何安装\n1.电脑多少位\n2. 软件官网 选对应的os，对应的位数\n我习惯选zip 解压就能用\n\n安装的文件夹路径，最好全英文\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('H5 \t\n狭义:标签的本身\n广义：html5+css3+javascript \n\nCSS3： CSS1-CSS2-CSS3\n狭义：相关样式\n\nhtml5新特性总结\n新增元素\n语义化更好的标签元素：结构分明，有利于维护，有利于seo\n\t1. 结构元素：article、aside、header、hgroup、footer、figure、section、nav\n\t2. 音视频：audio video\n\t3. 画布 canvas 矢量图svg\n\t4. 其他元素：embed、mark、progress、meter、time、command、details、datagrid、keygen、output、source、menu、ruby、wbr、bdi、dialog\n\n新增的API\n\t\t1. Canvas：首先获取canvas元素的上下文对象，然后使用该上下文对象中的绘图功能进行绘制。\n\t\t<canvas id="canvas"></canvas>\n\t\t<script>\n\t\t\tvar canvas = document.getElementById("canvas");\n\t\t  \tvar context = canvas.getContext("2d");\n\t\t\t//设置颜色，默认为black\n\t\t  \tcontext.fillStyle = "red";\n\t\t  \tcontext.fillRect(0,0,100,100);\n\t\t  \t//默认为black\n\t\t    context.strokeStyle = "blue";\n\t\t  \tcontext.strokeRect(120,0,100,100);\n\t\t<\/script>\n\t\t\n\t\tSVG：SVG是html5的另一项图形功能，是一种标准的矢量图形，是一种文件格式，有自己的API。\n\t\t<svg height=100 width=100>\n\t\t\t<circle cx=50 cy=50 r=50/>\n\t\t</svg>\n\t\t\n\t\t音频和视频：2大好处,一是作为浏览器原生支持的功能，新的audio和video元素无需安装；二是媒体元素向web页面提供了通用、集成和可脚本化控制的API。\n\t\t<video src="video.webm" controls>\n\t\t\t<object data="videoplayer.swf" type="application/x-shockwave-flash">\n\t\t      <param name="movie" value="video.swf" />\n\t\t      Your browser does not support HTML5 video.\n\t\t  </object>\n\t\t</video>\n\t\t\n\t\t浏览器支持性检测：用js动态创建，检测特定函数是否存在。\n\t\tvar hasVideo = !!(document.createElement(\'video\').canPlayType);\n\t\t\n\t\tGeolocation：可以请求用户共享他们的位置。位置信息来源IP地址、三维坐标、GPS、从RFID、Wifi和蓝牙到Wifi的MAC地址、GSM或CDMA手机的ID、用户自定义数据\n\t\tnavigator.geolocation.getCurrentPosition(updateLocation,handleLocationError);\n\t\t//更新位置信息\n\t\tfunction updateLocation(position){\n\t\t  //纬度\n\t\t  var latitude = position.coords.latitude.\n\t\t  //经度\n\t\t  var longitude = position.coords.longitude.\n\t\t  //准确度\n\t\t  var accuracy = position.coords.accuracy.\n\t\t  //时间戳\n\t\t  var timestamp = position.coords.timestamp.\n\t\t  }\n\t\t//处理错误信息\n\t\tfunction handleLocationError(error){\n\t\t  console.log(error);\n\t\t}\n\t\t//监听位置更新\n\t\tvar watchId=navigator.geolocation.watchPostion(updateLocation,handleLocationError);\n\t\t//不再接收位置更新\n\t\tnavigator.geolocation.clearWatch(watchId);\n\t\t\n\t\tCommunication：跨文档消息通信，可以确保iframe、标签页、窗口间安全地进行跨源通信。 \n\t\t//发送消息\n\t\twindow.postMessage(\'hello,world\',\'http://www.example.com\');\n\t\t//接收消息\n\t\twindow.addEventListener(\'message\',messageHandler,true);\n\t\tfunction messageHandler(e){\n\t\t  switch(e.origin){\n\t\t    case \'friend.example.com\':\n\t\t      //处理消息\n\t\t      processMessage(e.data);\n\t\t    break;\n\t\t    default:\n\t\t    break;\n\t\t  }\n\t\t}\n\t\t\n\t\t• XMLHttpRequest Level2：改进了跨源XMLHttpRequest和进度事件，XMLHttpRequest Level2通过CORS实现了跨源XMLHttpRequest。跨源HTTP请求包含一个Origin头部，它为服务器提供HTTP请求的源信息。\n\t\t• WebSockets：要连接远程主机，只需新建一个WebSocket实例，提供希望连接的对端URL。\n\t\t• Forms：新表单元素tel、email、url、search、range、number 未来的表单元素color、datetime、datetime-local、time、date、week、month\n\t\t• 新表单特性和函数：placeholder、autocomplete、autofocus、spellcheck、list特性、datalist元素、min和max、step、required\n\t\t• 拖放API：draggable属性、拖放事件(dragstart、drag、dragenter、dragleave、dragover、drap、dragend)、dataTransfer对象\n\t\t\n\t\t\n\t\t<div id="draggable" draggable="true">Draggable Div</div>\n\t\t<script>\n\t\t  var draggableElement = document.getElementById("draggable");\n\t\t  draggableElement.addEventListener(\'dragstart\',function(event){\n\t\t    console.log("拖动开始！");\n\t\t    event.dataTransfer.setData(\'text\',\'hello world!\');\n\t\t  })\n\t\t<\/script>\n\t\t\n\t\t\n\t\t• Web Storage API：sessionStorage(保存在session中，浏览器关闭，数据消失)、localStorage(保存在本地\n\t\t//sessionStorage和localStorage方法一致\n\t\t//保存数据\n\t\tlocalStorage.setItem(key,value);\n\t\t//读取数据\n\t\tlocalStorage.getItem(key);\n\t\t//删除单个数据\n\t\tlocalStorage.removeItem(key);\n\t\t//删除所有数据\n\t\tlocalStorage.clear();\n\t\t//得到某个索引的key\n\t\tlocalStorage.key(index);\n\t\t\n\t\t• Web Workers API：Web Workers可以让Web应用程序具备后台处理能力，对多线程的支持性非常好。\n\t\t但是在Web Workers中执行的脚本不能访问该页面的window对象，\n\t\t也就是Web Workers不能直接访问Web页面和DOM API。\n\t\t虽然Web Workers不会导致浏览器UI停止响应，但是仍然会消耗CPU周期，导致系统反应速度变慢。\n\t\t新开子线程，实际还是单线程\n\t\t\t用于大数据处理 或 耗费时间较长的操作\n\n')])])]),t("h2",{attrs:{id:"canvas画布"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canvas画布"}},[n._v("#")]),n._v(" canvas画布")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("https://www.bilibili.com/video/BV1Er4y117Hs?p=18\n  <style>\n    #canvas{\n      /* 原本是行内元素 */\n      display: block;\n      margin: 0 auto;\n      border: 1px solid #aaa;\n    }\n  </style>\n</head>\n\x3c!-- 网页的主体，展示用户所见内容 --\x3e\n<body>\n  \x3c!-- 兼容性问题 --\x3e\n  \x3c!-- 如果支持canvas不会显示这句话 --\x3e\n  <canvas id=\"canvas\" width=\"500px\" height=\"500px\">您的浏览器版本过低，请升级浏览器或用chrome打开！</canvas>\n  <script>\n    // 如果在canvas画一条直线 操作canvas只能用原生js 不要用jQuery\n    // 1.获取dom元素\n    var canvas = document.querySelector('#canvas')\n    // 2.获取绘图权限  只有2d\n    var c = canvas.getContext('2d')\n    // 3.开启一条路径 \n    c.beginPath()\n    // 4.确定起点和终点\n    c.moveTo(100,100)\n    c.lineTo(200,200)\n    // lineTo可以连用\n    c.lineTo(400,300)\n    // 5.上色\n    // 设置颜色和线宽\n    c.strokeStyle = 'green'\n    c.lineWidth = 5 //表5px\n    c.stroke()\n    // 6.关闭路径\n    c.closePath()\n  <\/script>\n\n")])])]),t("h2",{attrs:{id:"画矩形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#画矩形"}},[n._v("#")]),n._v(" 画矩形")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 如果在canvas画一条直线 操作canvas只能用原生js 不要用jQuery\n    // 1.获取dom元素\n    var canvas = document.querySelector('#canvas')\n    // 2.获取绘图权限  只有2d\n    var c = canvas.getContext('2d')\n    // 矩形分类 \n    // 普通矩形rect  能描边也能填充\n    // 空心矩形strokeRect 不能填充\n    // 实心矩形fillRect  不能描边\n    // rect(x,y,width,height) //默认空心\n    c.rect(100,100,200,200)\n    // 注意先填充再描边 反之则到时边看起来像2px\n    // 填充\n    c.fillStyle = 'green'\n    c.fill()\n    // 描边\n    c.strokeStyle = 'red'\n    c.lineWidth = 5\n    c.stroke()\n    // 清楚画布 clearRect(x,y,width,height)\n    clearRect(100,100,200,200)\n\n")])])]),t("h2",{attrs:{id:"音视频"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#音视频"}},[n._v("#")]),n._v(" 音视频")]),n._v(" "),t("h2",{attrs:{id:"h5-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#h5-新特性"}},[n._v("#")]),n._v(" h5 新特性")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("h5 新特性 兼容问题I9+\n1.新增语义标签(常用部分)\nheader\nnav\narticle\nsection 大型号div\naside 侧边栏\nfooter\n注意：\n1.这些标签主要针对搜索引擎\n2.这些新标签页面中可以用多次\n3.IE9需要将这些元素转为块级元素\n4.移动端更喜欢用这些标签\n5.以上只是部分标签\n\naudio \nvideo\n非常方便地嵌入视频和音频\n\ninput新增type\n重点;number tel search\nemail  url date time month week number tel search color\n\n新增表单属性\n重点：placeholder 提示文本，搜索框默认值 multiple（使得type是file的可以选择多个文件提交）\n修改颜色 input::placeholder{color:pink}\nautofocus 自动获取焦点\nautocomplete off/on 记录正确输入的历史，不安全\nrequired 表内容不能为空\n\n")])])]),t("h2",{attrs:{id:"form标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#form标签"}},[n._v("#")]),n._v(" form标签")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("提交表单默认行为：跳转页面\ne.preventdefault\n\nAction:默认值当前页面地址\n\nTarket: self 为当前页面 /窗口  blank为新页面\n\nMethod: get会将数据以url形式提交，即加在目标地址后面\n\t适合：少量 简单 不隐蔽\nPost:更为隐蔽，以form data形式提交\n\t适合：大量 复杂 以及文件上传\n\nEnctype: 默认值：第一个长的，表发送编码前所有字符\n\tMultipart/form-data 表不对字符编码，文件上传时，必须用\n\t最后一个，表将空格转为+，但不对特殊字符编码，很少用\n\t\n什么是表单同步提交\n\t1.页面跳转\n\t2.返回到之前的页面，页面的状态和数据会丢失\n方案：表单只负责采集，ajax负责提交数据\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("web worker\n不常用\n1.慢\n2.不能跨域加载JS //域：域名\n3.内代码不能访问DOM（更新UI）/全局对象不是window\n4.不是每个浏览器都支持\n\n斐波那契数列\nF(0) = 1, F(1)= 1,...F(n)=F(n-1)+F(n-2)\n函数实现\n\tfunction fib(n){\n\treturn n <=2 ? 1 : fib(n-1) + fib(n-2) //递归：自己调自己\t\n}\nvar input = querySelector\nvar btn = querySelector\nbtn.addEventListener = function('click'){\n\tvar number = input.value\n\tvar result = fib(number)\n\talert(result)\n}\n递归效率很低，嵌套调用，占用很多空间\n将这个计算量大的代码交给web worker运行\n\nweb worker提供了一个js多线程解决方案\n\t但子线程完全受主线程控制，且不能操作DOM（依然是JS单线程本质：主线程更新界面）\n\n使用：\n\t1.创建一个js文件（在分线程执行）\n\t2.主线程中的js发消息并设置回调\n\nbtn.addEventListener = function('click'){\n\tvar number = input.value\n\t//1.创建一个worker对象\n\tvar worker = new Woker('worker.js')\n\t//2.传送消息\n\tworker.postMessage(number)\n\t//3.获取返回结果\n\tworker.onmessage = function(event){\n\tconsole.log(event.data);\n\t}\n}\n\nworker.js 分线程中的代码\nfunction fib(n){\n\treturn n <=2 ? 1 : fib(n-1) + fib(n-2) //递归：自己调自己\t\n}\nvar onmessage = function(event){ //不能用函数声明\n\tconsole.log(this) // this是worker的一个全局对象\n\tvar number = event.data //接受数据\n\t//计算\n\tvar result = fib(number)\n\tpostMessage(rusult) //发送给主线程\n\tconsole.log(result) //console.log是浏览器的属性\n \n}\n因为分线程里中全局对象不再是window，所以无法更新界面\n")])])]),t("h2",{attrs:{id:"bom-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bom-dom"}},[n._v("#")]),n._v(" BOM DOM")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("如果有个变量，我们以后打算存储对象，暂时还没想好放什么，这时候给null，初始化\n栈：由操作系统自动分配释放存放：函数的参数值，局部变量的值等简单数据类型\nvar age = 18; 将18存到空间，age指向18(指向值)\n\n堆：存储对象，一般由程序员分配释放，若没有释放，则垃圾回收机制回收\nobj = {name : '毛'} \nobj 指向 栈空间里的地址值；这个地址值指向堆空间中的对象\n（注意，保存这个地址值得空间自身其实也有地址，不需要而已）\nvar num = 10\nnum = 20\n注意：string才不会被覆盖，开辟新空间\n\nfunction fn(a){\n      a++\n      console.log(a) //11\n    }\n    var x = 10\n    fn(x) \n    console.log(x) //10\n\nJS:ECMAScript(JS基础) + Web APIs(DOM + BOM)\nWeb API\nAPI:application programming interface 应用程序编程接口\n即：一种工具，以接口形式出现，一般为预定义的函数\n\n\n\n\nDOM：\n一个页面就是一个文档：document\n所有标签都是元素：element\n网页中所有的内容都可以看作节点(标签，属性，文本，注释等)：node\n标签节点\n属性节点\n文本节点\n注释节点\n\n获取元素\n作用，参数，返回值\n\tconsole.dir() //打印元素对象，更好地查看属性和方法\n\tdocument.getElementById()\n\t\t以下带s的，返回都是伪数组，如果为空，则返回空的伪数组\n\tdocument.getElementsByTagName() // 'li'\n\telement.getElementsByTagName() //想要获取ol下的li 不要ul下的li\n\t\t1.var ol = getElementsByTagName('ol') //返回的是伪数组，需转为单独的对象\n\t\t2.console.log(ol[0].getElementsbyTagName('li'))\n\n以下HTML5新增 IE9+\n\tdocument.getElementsByClassName()\n\tdocument.querySelector('选择器') //返回指定选择器的第一个元素对象，注意选择器符号\n\t\tvar firstBox = document.querySelector('.box') //获取第一个class为box的元素对象\n\tdocument.querySelectorAll(）\n//获取class为baidu 的ul下的img\n\tvar imgs = document.querrySelector('.baidu').querrySelector('img')\n\n事件基础\n    window.onload = function (){\n      var btn = document.getElementById('btn')\n      btn.onclick = function (){\n        alert('点了以下')\n      }\n    }\n\t1.鼠标事件\n\tonmouseover\n\tonmouseout\n\n操作元素\n\telement.innerText //不识别html标签，同时会去除空格和换行\n\telement.innerHTML 推荐 //普通盒子的内容\n\n\t\n表单元素的属性操作\n\ttype value checked selected disabled\n\tvalue:表单的内容\n\t元素.属性\n表单新事件\n\tonfocus\n\tonblur\t\n\n通过JS修改元素样式：行内样式，权重高\n\telement.style // this.style.backgroundColor(驼峰) = 'yellow'\n\n\telement.className // this.className = '原来的类 新的类 change'\n\nwindow.onload = function (){\n      var ipt = document.querySelector('.ipt')\n      var meg = document.querySelector('.message')\n      ipt.onblur = function (){\n        if (this.value.length < 6 || this.value.length > 16){\n          meg.className = 'message wrong'\n          meg.innerHTML = '您输入的位数不对'\n        }else{\n          meg.className = 'message right'\n          meg.innerHTML = '打钩，通过背景图片实现'\n        }\n      }\n    }\n\n排他思想\n\nwindow.onload = function (){\n      var btns = document.getElementsByTagName('button')\n      for (i = 0; i < btns.length; i++){\n        btns[i].onclick = function (){\n          //排他思想，先清楚所有的元素样式，再给当前元素设置样式\n          for (i = 0; i < btns.length; i++){\n            btns[i].style.backgroundColor = ''\n          }\n          this.style.backgroundColor = 'pink'\n        }\n      }\n    }\n获取元素\n\t1.利用DOM提供的方法\n\tdocument.getElementByID() 、、、//逻辑性不强，繁琐\n\t2.利用节点层次关系获取\n\t\t利用父子兄弟节点关系获取 //兼容性问题\n获取元素的属性值\n\t元素.属性 //获取内置的属性\n\telement.getAttribute('属性') //主要用于获取到自定义属性,目的是为了保存一些数据在页面，没必要从数据库中取\n\t\t//H5规定：所有自定义属性由data-开头\n\telement.dataset.index 或 element.dateset['index'] //IE11+ H5新增\n\t//如果是data-list-name = 'andy' 含有多个-，获取时采用驼峰命名法 listName\n设置元素的属性值\n\t元素.属性 = '值'// className\n\telement.setAttribute('属性','值')  注意设置class属性时，class\n\t\n移除元素的属性\n\telement.removeAttribute()\n\n节点\n1.nodeType// 元素为1 属性为2 文本为3（文字，空格，换行），实际中主要操作元素节点\n2.nodeName\n3.nodeValue\n\n根元素html\n父节点:\tnode.parentNode\n子节点: 1.parentNode.childNode //子节点集合，也会把文本节点获取到 不推荐\n\t2.parent.Children //子元素节点 推荐！\n\t3.parent.Children[0] //推荐！\n\t以下不推荐\n\t3.parent.firstChild //第一个子节点，含文本\n\t4.parent.lastChild //最后一个子节点，含文本\n\t5.parent.firstElementChild //第一个子元素 IE9+\n\t6.parent.lastElementChild //最后一个子元素 IE9+\n兄弟节点\n\tnode.nextSibling //下一个兄弟节点 含文本\n\tnode.previousSibling\n\tnode.nextElementSibling IE9+\n\tnode.previousElementSibling IE9+\n封装一个兼容性函数\n\tfunction getNextElementSibling(element){\n\t  var el = element\n\t  while(el = el.nextSibling){\n\t    if(el.nextSibling ===1){\n\t\treturn el\n\t    }\n\t  }\n\t  return null\n\t}\n\n动态创建节点\n\tdocument.createElement('tagName')// var li = document.createElement('li')\n追加节点\n\tnode.appendChild(child)//  var ul = document.querySelector('ul') ul.appendChild(li) \n插入节点 node.insertBefore(新,ul.child[0]（目标前）) \n\n\n\t\n删除节点\n\tnode.removeChild(child)\n\n\tif(ul.children.length === 0){\n        this.disabled = true\n      }else {\n        ul.removeChild(ul.children[0])\n      }\n\n复制节点\n\tnode.cloneNode()//参数为空或false，只会拷贝节点本身，不复制里面内容\n留言发布案例\t\n\n\twindow.onload = function (){\n      var btn = document.querySelector('button')\n      var text = document.querySelector('textarea')\n      var ul = document.querySelector('ul')\n      btn.onclick = function (){\n        if (text.value === ''){\n          alert('请输入内容')\n          return false\n        }else {\n          //创建\n          var li = document.createElement('li')\n          //添加\n          li.innerHTML = text.value + '<a href=\"javascript:;\">删除</a>' +'<a href=\"javascript:;\">复制</a>'\n          ul.insertBefore(li,ul.children[0])\n          //删除当前链接的li\n          var as = document.querySelectorAll('a')\n          // for (var i = 0; i < as.length; i++){\n          //   as[i].onclick = function (){\n          //     //父.removeChild(子)\n          //     ul.removeChild(this.parentNode)\n          //   }\n          // }\n          //复制\n          for (var i = 0; i < as.length; i++){\n            as[i].onclick = function (){\n              var lii = this.parentNode.cloneNode(true)\n              ul.appendChild(lii)\n            }\n          }\n        }\n      }\n\n三种动态创建元素区别（了解）\n1.document.write('<div>123</div>')//如果文档流执行完毕，会导致页面全部重绘；原先内容去除，重新创建一个页面，里面只有html body div \n2.element.innerHTML 与3单个时候，没区别；区别在于批量创建的执行时间，效率不一样 （低）；+= 拼接字符串，开辟新空间，效率低\n\t用数组形式，1.把a放入数组 2.数组放入InnerHTML 效率比createElement 还高 ；结构稍复杂\n\tvar array = []\n    for (var i =0; i < 1000; i++){\n      array.push('<div style=\"width: 100px; height: 2px; border: 1px solid blue;\"></div>')\n    }\n    document.body.innerHTML = array.join('');\n\t\n3.document.createElement() \n\n注册事件，添加事件，绑定事件、\n\t传统:on开头;onclick = function //同一个元素，同一个事件，只能设置一个处理函数\n\t方法监听方式（推荐）:Target.addEventListener('type',listener[,useCapture])\n\t IE9+ 可以用Target.attachEvent('带On',callback);！不推荐\n\tuseCapture：默认false\n\t\n\tvar btns = document.querySelectorAll('button')\n    btns[1].addEventListener('click',function (){\n      alert('22')\n    })\n    btns[1].addEventListener('click',function (){\n      alert('33')\n    })\n注册事件兼容性解决(了解)\n\tvar btns = document.querySelectorAll('button')\n    addEventListener(btns[1],'click',function (){\n      alert('hi')\n    })\n    //兼容性处理原则；先照顾大多数浏览器，再处理特殊浏览器\n    function addEventListener(element,eventName,fn){\n      if (element.addEventListener){\n        element.addEventListener(eventName,fn)\n      }else if(element.attachEvent){\n        element.attachEvent('on'+eventName,fn)\n      }else{\n        element['on'+eventName] = fn\n      }\n    }\n\n删除事件\n\t传统：event.onclick = null\n\t监听：Target.removeEventListener(type,fn(不能直接用匿名函数))\n\tvar btns = document.querySelectorAll('button')\n    btns[1].addEventListener('click',fn)\n    function fn(){\n      alert('22')\n      btns[1].removeEventListener('click',fn)\n    }\n\tattach解绑：target.detachEvent('onclick',fn)\n\n\t//兼容性解决方案\n\tfunction removeEventListener(element,eventName,fn){\n      if (element.removeEventListener){\n        element.removeEventListener(eventName,fn)\n      }else if(element.detachEvent){\n        element.detachEvent('on'+eventName,fn)\n      }else{\n        element['on'+eventName] = null\n      }\n    }\nDOM事件流\n\t捕获阶段：父-子 document-html-body-father-son\n\t冒泡阶段：子-父 son-father-body-html-document\n\t1.JS代码要么只能处于捕获 要么只能处于冒泡\n\t2.传统事件onclick,attachEvent 只能冒泡\n\t3.addEventListener() 第三个参数默认false表冒泡\t\n\n有些事件没有冒泡\n\tonblur onfocus onmouseenter onmouseleave\t\n事件对象 \n\t事件对象只有有了事件才能存在，系统自动创建的，不需要传递参数\n\t是事件的一系列相关数据的集合，比如鼠标点击，包含鼠标坐标等；键盘事件，包含用户按下哪个键\n\t可以自己命名比如event,evt,e\n\tIE678警告！ 使用window.event\n\tdiv.onclick = function(事件对象event（当形参看）){}\n\tdiv.addEventListener('click',function(event){})\n\t//兼容性写法\n\te = e ｜｜window.event\n常见的事件对象的属性和方法\n\te.target //触发点击事件的元素 注意与this（事件绑定的对象）的区别\n\te.srcElement// IE678\n\n\te.currenttargetn // 同this\n\te.type //返回事件类型\n\te.preventDefault() //阻止默认行为 比如链接跳转 \n\te.returnValue //ie678\n\treturn false //阻止默认行为，但是后面代码不执行了，不能用在监听\n\n阻止冒泡！\n\te.stopPropagation()\n\twindow.event.canselBubble = true // IE678\n事件委托，事件委派（JQuery）\n\tul里有1000个li，点击li弹出alert，给父节点ul添加事件\n\t想要点击li，给li设置背景颜色\n\t通过e.target获取\n\n鼠标事件\n\tonmousemove 鼠标移动\n\tonmouseup 鼠标松开\n\tonmousedown 鼠标按下\n\t//禁止鼠标右键菜单\n\tcontextmenu //主要控制应该何时显示上下文菜单；主要用于程序员取消默认的上下文菜单\n\tdocument.addEventListener('contextmenu',function(e){e.preventDefault()}) //还是可以ctrl+c\n\t//禁止鼠标选中\n\tdocument.addEventListener('selectstart',function(e){e.preventDefault()})\n\t\n鼠标事件对象mouseEvent\n\te.clientX //可视区X坐标\n\te.pageX //相当于文档页面 IE9+ !推荐，用的多\n\te.screenX //相当于屏幕\n//图片跟随鼠标\n\tvar img = document.querySelector('img')\n    document.addEventListener('mousemove',fn)\n    function fn(e){\n      img.style.left = e.pageX - 50 + 'px'\n      img.style.top = e.pageY - 59 + 'px'\n    }\n\n\n键盘事件对象keyboardEvent\n\tonkeyup //弹起\n\tonkeydown//按下 不松开会一直触发\n\tonkeypress//按下 同上，区别在于不会识别功能键ctrl shift 箭头等，即按下ctrl 不会触发\n执行顺序 down > press > up 不区分代码位置\n\n键盘事件对象的属性和方法\n\te.keyCode //得到该键的ASC码值，A和a都是65\nkeyup和down不缺分大小写，可以用keyPress\n\n\t//按下s 搜索框获取焦点\n\n\tvar search = document.querySelector('input')\n    document.addEventListener('keyup',fn1) //用keydown s会写进去，换up不会\n    function fn1(e){\n      if (e.keyCode === 83){\n        search.focus()\n      }\n    }\n\n\t//京东搜索单号案例，原本小框，输入内容后，上面出现大框\n\n\tvar con = document.querySelector('.con')\n      var jd_input = document.querySelector('.jd')\n      jd_input.addEventListener('keyup',function (){\n        if (this.value === ''){\n          con.style.display = 'none'\n        }else{\n          con.style.display = 'block'\n          con.innerHTML = this.value\n        }\n      })\n      jd_input.addEventListener('blur',function (){\n        con.style.display = 'none'\n      })\n      jd_input.addEventListener('focus',function (){\n        if (this.value !== ''){\n          con.style.display = 'block'\n        }\n      })\n\nwindow是JS访问浏览器的一个接口\n也是一个全局对象，在全局作用域下的变量或函数都会变成window对象的属性和方法，只是调用时，省略window\n比如alert() fn() 实际是 window.fn()\n\nBOM\t\n\t最大的对象window\n\twindow含document location navigation screen history\t\n\nwindow对象常见事件\n\twindow.onloada = function(){} //窗口加载事件，当文档内容完全加载完后，会触发该事件\n\twindow.addEventListener('load',function{})\n\n\tdocument.addEventListener('DOMContentLoaded',function(){}) //仅当DOM加载完成后，不包含CSS，图片等 IE9+\n\t应用场景：图片特别多的情况下，上面加载的慢，这时候用这个\n\n调整窗口大小事件:当窗口大小变化，就会触发函数\n\twindow.resize = function(){}\n\twindow.innerWidth //当前屏幕的宽度 \n\n定时器\n\tsetTimeout(回调函数，【延迟的毫秒数，中括号表省略】)\n\t\tvar timer1 = setTimeout(function(){},2000ms)，只调用一次\n\tsetInterval()//大体同上，但是这个是反复调用，每隔2秒调用一次\n回调函数：需要等待时间，事件触发了，时间到了回头去调用，叫做回调函数\n\n停止定时器\n\tclearTimeout(（ID如）timer1)\n\tclearInterval() //注意 var timer = null 全局变量\n\n\tvar hour = document.querySelector('.hour')\n\tvar minute = document.querySelector('.minute')\n\tvar second = document.querySelector('.second')\n\tvar inputTime = +new Date(time)\n\tcountDown();//在开启定时器之前，先调用一次\n\tsetInterval(countDown,1000ms) //重新刷新，会刷新页面，第一次执行也有间隔毫秒数\n\tfunction countDown(){\n      var nowTime = +new Date()\n      var times = (inputTime - nowTime) / 1000      \n      var h = parseInt(times / 3600 % 24)\n      h = h < 10? '0' + h : h\n\thour.innerHTML = h\n      var m = parseInt(times / 60 % 60)\n      m = m < 10? '0' + m : m\n\tminite.innerHTML = m\n      var s = parseInt(times % 60)\n      s = s < 10? '0' + s : s\n\tsecond.innerHTML =s\n      \n    }\n\n//手机验证码\n\t手机号码：<input type=\"number\"> <button>发送</button>\n  <script>\n    var btn = document.querySelector('button')\n    var time = 3\n    btn.addEventListener('click',function (){\n      btn.disabled = true\n      var timer = setInterval(function (){\n        if (time == 0){\n          clearInterval(timer)\n          btn.disabled = false\n          btn.innerHTML = '发送'\n          time = 3\n        }else{\n          btn.innerHTML = '还剩下'+time+'秒'\n          time--\n        }\n      },1000)\n\n\nJS执行机制\n\t1.单线程.H5中出现同步异步\n\t同步：先烧水，再切菜，再炒菜\n\t异步：边烧水，边切菜...\n\tconsole.log(1)\n\tsetTimeout(function(){\n\t\tconsole.log(3)\n\t},1000)\n\tconsole.log(2)\n\t输出结果:1,2,3 而不是132 ，即便时间间隔是0 也是 1,2,3\n\n\t同步任务：都在主线程的执行站，console.log(1) setTimeout(fn,1000) console.log(2)\n\t异步任务：普通事件click 资源加载load 定时器\n\t\t异步任务相关的回调函数添加到任务队列中，也成为消息队列\n\n执行顺序\n\t1.执行执行栈中的同步任务\n\t2.遇到异步任务，将其放入任务队列中\n\t3.同步任务完成，按顺序读取任务队列中的异步任务，放到执行栈（叫做事件循环） 先进先出\n\n异步任务\n\t异步进程处理，如果click没点击，则不会放入\n\nlocation对象\n\t用于获取或设置窗体的url，并且可以用于解析url\n\turl:统一资源定位符uniform resource locator,互联网上每个文件都有一个唯一的url，包含地址值和浏览器如何处理它\n属性\n\tlocation.href //获取或设置整个url\n\tlocation.search //返回参数\n\n第一个登录页面，提交表单到index.html\n第二个页面，可以使用第一个页面的参数，利用location.search 获取，再提取，\n去除？ substr 利用=号分割键值 split('=') \n\t//页面1\n\t<form action=\"index.html\">  //默认get提交\n    用户名：<input type=\"text\" name = 'uname'>\n    <input type=\"submit\" value=\"登录提交\">\n  </form>\n\t//页面2\n\tconsole.log(location.search) //?uname=andy\n    //去掉？ substr(起始位置，几个)\n    var params = location.search.substr(1) // uname=andy\n    //利用=将字符串分为数组\n    var arr = params.split('=')\n    var div = document.querySelector('div')\n    div.innerHTML = arr[1] + '欢迎你'\n\nlocation常见的方法\n\tlocation.assign('url') 记录历史，可后退\n\tlocation.replace()，不记录历史\n\tlocation.reload() //刷新F5，加true，强制刷新ctrl+F5\n\nNavigator对象，含有浏览器相关信息，比如PC还是移动，电脑版本，浏览器版本等\n\tuserAgent //浏览器\n\n//判断用户是什么浏览器，实现跳转\n    if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|WOSBrowser|WebOS|Symbian|Windows Phone)/i))){\n      window.location.href = ''; //手机\n    }else{\n      window.location.href = ''; //电脑\n    }\n\nhistory对象\n\t浏览器的后退和前进 OA系统可能用到\n\thistory.forward() \n\thistory.back()\n\thistory.go(1) // 2,...,-1\n\n元素可视区client系列\n\tclientTop/Left //上边框\n\tclientWidth // 含内容和padding 不含边框\n立即执行函数\n\t主要作用：创建独立作用域，避免命名冲突\n\t写法：( fn(){} )(); 或 ( fn(){}() );\n\t\noffsetWidth 包含边框\nclientWidth 不包含边框\nclientTop   上边框大小\n\npageshow事件：火狐后退不会刷新load事件，因为有往返缓存在内存中\ne.persisted 如果是true 表示从缓存取回来的页面\n\n元素滚动scroll系列\nclientWidth 盒子大小\nscrollWidth 内容大小（实际大小） \nscrollTop //被卷去的头部\nscrollLeft\nwindow.pageYOffset //页面被卷去的头部 IE9\n//淘宝侧边栏\n\tvar sliderbar = document.querySelector('.slider-bar')\n    var banner = document.querySelector('.banner')\n    var bannerTop = banner.offsetTop\n    var sliderbarTop = sliderbar.offsetTop - banner.offsetTop\n    document.addEventListener('scroll', function (){\n      if (windoe.pageYOffset >= 172) {\n        sliderbar.style.position = 'fixed'\n        sliderbar.style.top = sliderbarTop + 'px'\n      }else {\n        sliderbar.style.position = 'absolute'\n        sliderbar.style.top = '300px'\n      }\n    })\n\noffsetWidth\t含边框 \t\t\t获取元素位置left top\nclientWidth \t不含\t盒子大小\t获取元素大小width height\nscrollWidth\t不含\t内容大小\t获取滚动距离top left\nwindow.pageYOffset //页面被卷去的头部\n\nmouseover\t经过子盒子也会触发事件\nmouseenter\t只会经过自身盒子触发 经常搭配leaver\nmouseleaver\t同enter 不会冒泡\n\n动画函数\n\t原理：通过定时器setInterval() 不断移动盒子\n1.获取盒子当前位置\n2.位置+1\n3.定时器不断重复\n4.结束定时器条件\n注意：定位\n\n// 简单动画函数封装\n    function move(obj, target) {\n      //通过属性赋值的方法，实现给不同元素指定不同的定时器，优化var开辟新空间\n      clearInterval(obj.timer) //先清除定时器，避免重复叠加\n       obj.timer = setInterval(function (){\n        if (obj.offsetLeft >= target) {\n          clearInterval(obj.timer)\n        }\n        obj.style.left = obj.offsetLeft + 1 + 'px'\n      },30)\n    }\n\n缓动动画\n\t最常见：让速度慢慢停下来\n1.盒子每次移动距离慢慢变小\n2.算法：（目标值-现位置）/10 为步长\n3.停止条件：目标位置\n注意：步长取整\nvar step;\n    // 简单动画函数封装\n    function move(obj, target, callback) {\n      //通过属性赋值的方法，实现给不同元素指定不同的定时器，优化var开辟新空间\n      clearInterval(obj.timer) //先清除定时器，避免重复叠加\n       obj.timer = setInterval(function (){\n        if (obj.offsetLeft >= target) {\n          clearInterval(obj.timer)\n          callback();\n        }\n        //步长值,涉及到除法，可能除不断，到不了目标位置比如500，实际494.6，将step取整\n        // 正值往上取整，倒退应该往下取整 Math.floor\n         step = (target - obj.offsetLeft / 10);\n        step = step > 0? Math.ceil(step) : Math.floor(step)\n        obj.style.left = obj.offsetLeft + step + 'px'\n      },15)\n    }\n回调函数\n\t原理：将函数作为参数，传递到另一个函数中，当一个函数结束后，执行回调函数\n\t结束条件：动画的结束条件-停止计时器\n\t\n轮播图/焦点图原理\n\t1.鼠标经过后，左右按钮显示；离开时，消失\n\t2.左右按钮点击 滑动；ul在动 而不是li；移动距离 小圆圈的索引号*图片宽度\n\t3.小圆点对应图片顺序\n\t4.点击小圆点实现滑动\n\t5.自动播放\n\t6.鼠标经过后播放停止\n节流阀：当快速点击按钮时，播放会很快\n\t实现上个动画执行完后，才能执行下个动画，让案件无法连续触发\n\t回调函数：来锁住或解锁\n实现：var flag = ture\n\tif(flag){flag = false;do something}//关闭水龙头\n\t利用回调函数，flag = true\n\n返回顶部案例\n\twindow.scrll(x,y)//window.scroll(0,0)返回顶部，但是瞬移\n使用封装的动画函数，将所有left相关值改为跟页面垂直相关\n\twindow.pageYOffset得到页面滚动了多少\n\n// 返回顶部函数\n      function animate(obj, target, callback) {\n        clearInterval(obj.timer) //先清除定时器，避免重复叠加\n        obj.timer = setInterval(function (){\n          var step = (target - window.pageYOffset) / 10;\n          step = step > 0? Math.ceil(step) : Math.floor(step);\n          if (window.pageYOffset == target) {\n            clearInterval(obj.timer);\n            callback && callback();\n          }\n          window.scroll(0,window.pageYOffset + step)\n        },15);\n      }\n\n筋斗云案例\n1.鼠标经过某个li，筋斗云跟过来；离开返回\n2.点击了某个li，筋斗云就会留着，再移动到其他li，离开会返回到这个li上\n\n分析动画函数\n1.起始位置0\n2.li的offsetLeft作为目标值\n3.离开li，目标为0\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n\n\x3c!-- 文档声明：声明当前网页版本 --\x3e\n\x3c!-- <!DOCTYPE html>\n\x3c!-- html根标签 --\x3e\n\x3c!-- <html lang=\"en\"> --\x3e\n\x3c!-- 网页的头部，内部内容不会展示，主要用来帮助浏览器和搜索引擎来解析网页 --\x3e\n\x3c!-- <head> --\x3e\n  \x3c!-- meta标签用来设置网页的元数据 --\x3e\n  \x3c!-- 设置字符集，避免乱码 --\x3e\n\x3c!--   <meta charset=\"UTF-8\"> --\x3e\n  \x3c!-- 网页标签，title中的内容会显示在浏览器的标题栏 --\x3e\n  \x3c!-- 搜索引擎主要根据title的内容来判断网页的主要内容 --\x3e\n\x3c!--   <title>Title</title> --\x3e\n\x3c!-- </head> --\x3e\n\x3c!-- 网页的主体，展示用户所见内容 --\x3e\n\x3c!-- <body> --\x3e\n\x3c!-- </body> --\x3e\n\x3c!-- </html> --\x3e \n\n''' python\nprint(\"Hello，World!\")\n'''\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);