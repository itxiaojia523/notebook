(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{473:function(e,n,t){"use strict";t.r(n);var a=t(2),s=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("https://juejin.cn/post/7123203404557451271")]),e._v(" "),n("p",[e._v("？ 和 ! ！！\n!用法\n用在变量前表示取反\n用在赋值的内容后时，使null和undefined类型可以赋值给其他类型并通过编译，表示该变量值可空\n// 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x!\ninterface IDemo {\nx?: number\n}")]),e._v(" "),n("p",[e._v("let y:number")]),e._v(" "),n("p",[e._v("const demo = (parma: IDemo) => {\ny = parma.x!\nreturn y\n}")]),e._v(" "),n("p",[e._v("?用法\n除了表示可选参数外，常用于防御性编程\n如果无法确定A是否为空，则需要用A?.B\n表示当A有值的时候才去访问B属性，没有值的时候就不去访问，如果不使用?则会报错")]),e._v(" "),n("p",[e._v("但是?用法只能读操作而不能写操作，对一个可能为空的属性赋值是不会被编译通过的，此时还需用用到类型断言")]),e._v(" "),n("p",[e._v("interface IDemo {\nx: number\n}")]),e._v(" "),n("p",[e._v("// 编译报错，不能赋值给可选属性\nconst demo = (parma?: IDemo) => {\nparma?.x = 1\t\n}")]),e._v(" "),n("p",[e._v("// 使用类型断言"),n("br"),e._v("\nconst demo_ = (parma?: IDemo) => {\nlet _parma = parma as IDemo\n_parma.x = 1\n}")]),e._v(" "),n("p",[e._v("// !！ 表转化为布尔值")]),e._v(" "),n("p",[e._v("高阶组件\n高阶组件是参数为组件，返回值为新组件的函数")]),e._v(" "),n("p",[e._v("//父组件role\nconst Role = ():ReactElement=>{\n    const authRef = useRef(null)\n   // 更新角色（权限）\n    const updateRole = async()=>{\n        // 隐藏确认框\n        setIsModalVisible(0)\n        // 需要最新的menus 从子组件取checkedKeys 状态\n       \n        const menus = authRef.current?.getMenus()\nconsole.log(authRef) //null\n        console.log(menus);\n       \n    }")]),e._v(" "),n("p",[e._v("return (\n        "),n("Card",{attrs:{title:"{title}"}},[e._v('\n            <Modal\n                title="设置角色权限"\n                visible={isModalVisible === 2}\n                onOk={updateRole}\n                onCancel={()=>{setIsModalVisible(0)}}>\n//子组件\n                '),n("AuthForm",{attrs:{role:"{role}",authRef:"{authRef}/"}})],1),e._v("\n}\n//子组件\nconst AuthForm= (props:Iprops,authRef:any) =>{\n//定义并暴露getMenus方法\n    const getMenus = () => checkedKeys\n    useImperativeHandle(\n        authRef,\n        () => ({\n            getMenus\n        })\n    )")],1),e._v(" "),n("p",[e._v("return (\n        <>\n            "),n("Item",{attrs:{label:"角色名称"}},[n("Input",{attrs:{value:"{role.name}",disabled:""}})],1),e._v(" "),n("Tree",{attrs:{checkable:"",expandedKeys:"{expandedKeys}",checkedKeys:"{checkedKeys}",onCheck:"{onCheck}",treeData:"{treeData}"}}),e._v("\n        </>\n    )")],1),e._v(" "),n("p",[e._v("}\nexport default forwardRef(AuthForm)")]),e._v(" "),n("p",[e._v("符号\n  let value = 'visible'\n        let result = \"我叫:\" + value === 'visible' ?  'Tom' : 'mary'\n        // 加号的优先级高于条件运算符\n        let result1 = (\"我叫:\" + value) === 'visible' ?  'Tom' : 'mary'\n        // 注意加括号\n        let result2 = \"我叫:\" + (value === 'visible' ?  'Tom' : 'mary')\n        console.log(result); //mary\n        console.log(result1); //mary\n        console.log(result2); //我叫:Tom")]),e._v(" "),n("p",[e._v("// !!获取一个值的boolean值  !表取这个值的boolean值并取反\n        console.log(!3); // false\n        console.log(!!3); //true")]),e._v(" "),n("p",[e._v("父组件调用函数子组件的方法\n关键点： useRef, useImperativeHandle, forwardRef")]),e._v(" "),n("p",[e._v("父组件bar.tsx 子组件barchild.tsx\n1.父组件使用 useRef 创建一个 ref 传入 子组件\nconst bcRef = useRef(null)\n"),n("BarChild",{ref:"{bcRef}/"},[e._v("\n//之前这里写错了 写成bcRef = {bcRef} 卡了一天")])],1),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li")]),e._v(" "),n("p",[e._v("。\n2.子组件暴露时需要用 forwardRef 包裹着\nexport default forwardRef(BarChild)\n注意不能写成:FC了\nconst BarChild = (props:any,bcRef:any):ReactElement=>{}")]),e._v(" "),n("p",[e._v("3.使用 useImperativeHandle 部分暴露子组件\n    const getMenus = ()=> 123\n    useImperativeHandle(\n        bcRef,\n        () => ({\n            getMenus //只暴露getMenus方法给父组件\n        })\n    )")]),e._v(" "),n("p",[e._v("4.在父组件调用\n//注意问号\n        const result = bcRef.current?.getMenus()")])])}),[],!1,null,null,null);n.default=s.exports}}]);