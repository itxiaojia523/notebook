(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{423:function(n,t,s){"use strict";s.r(t);var o=s(2),a=Object(o.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h1",{attrs:{id:"作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[this._v("#")]),this._v(" 作用域")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("变量找作用域链，属性找原型链（找不到返回undefined）\n\n作用域是指程序源代码中定义变量的区域。\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n作用：隔离变量，不同作用域下同名变量不会有冲突\nJavaScript 采用词法作用域(lexical scoping)，函数作用域基于函数创建的位置，也就是静态作用域。\n\n分类\n\t1.全局\n\t2.函数\n\t3.块作用域（es6+），即{}作用域\n\t\n分类2：静态作用域和动态作用域\n\n个数：n+1 n是定义几个函数，在定义时确定，静态\n与执行上下文不同：n是调用几个函数，在调用时确定，动态，调用结束后释放\n\n联系：执行上下文 从属于 所在的作用域\n\n作用域链：由内向外\n函数作用域基于函数创建的位置\nvar x = 10\nfunction fn() {\n  console.log(x)\n}\nfunction show(f){\n  var x = 20\n  f()\n}\nshow(fn)\n\n结果是10，要根据作用域找，fn 和 show的作用域是并列的\n\nvar fn = function (){\n  console.log(fn)\n}\nfn() //输出函数  简单\n\nvar obj = {\n  fn2: function (){\n    console.log(fn2)\n  }\n}\nobj.fn2() //报错！！自身作用域找fn2 没有，再往上全局也没有\n要找对象中的fn2，得改为 this.fn2  区别？？？？？？？？？？？？\n\n动态作用域\nbash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。\n\nvalue=1\nfunction foo () {\n    echo $value;\n}\nfunction bar () {\n    local value=2;\n    foo;\n}\nbar\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);