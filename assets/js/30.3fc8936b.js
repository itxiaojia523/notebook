(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{464:function(n,t,e){"use strict";e.r(t);var o=e(2),a=Object(o.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('方法1\t原型链继承\n\t步骤\n1.定义父子构造函数\n2.为使得子的实例 能访问父的原型的方法\n3.子类型的原型为父类型的一个实例对象\n\n关键：子类型的原型为父类型的一个实例对象\n\n  //父的实例 能访问父的原型\n  //子的实例 能访问子型\n  //把子的原型 指向 父的实例\n  //子实例 - 子原型 - 父实例 - 父原型\t\n\n//定义父\nfunction Parent(){\n    this.pProp = "parent Prop"\n  }\n  Parent.prototype.showParentProp = function () {\n    console.log(this.pProp)\n  }\n//定义子\n  function Sub(){\n    this.sProp = "sub Prop"\n  }\n  Sub.prototype.showSProp = function () {\n    console.log(this.sProp)\n  }\n\n  \n  //让子类型的原型 成为 父类型的实例\n  Sub.prototype = new Parent()\n  s1.showParentProp() //希望子类型的实例 能调用父类型原型上的方法 让子类型的原型\n 成为 父类型的实例\n\nvar s1 = new Sub()\nconsole.log(s1.constructor) // Parent 不对需要改\nSub.Prototype.constructor = Sub\n\n\n方法2 用call（）的假继承\n function P(name,age) {\n    this.name = name\n    this.age = age\n  }\n\n\n  function Student(name,age,price) {\n    P.call(this, name, age) // 结果同this.P(name, age)\n    this.price = price\n    \n  }\n\n最终：组合继承\ncall()函数搞来属性，继承搞来方法\n\n function Person(name,age) {\n    this.name = name\n    this.age = age\n  }\n\tPerson.prototype.setName = function(){}\n\t...多个方法\n\n  function Student(name,age,price) {\n    Person.call(this, name, age) //为了得到属性\n    this.price = price\n  }\n\tStudent.prototype = new Person() //为了看到父类型的方法\n\tStudent.prototype.constructor = Student //修正构造器\n\n不申明a\n直接log(window.a)//undefined log(a) //报错\n找作用域 与 代码执行位置无关！ ！！！\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);