(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{456:function(t,n,e){"use strict";e.r(n);var s=e(2),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" activeIndex 作为 state，就有两种不同的视角。\n activeIndex 在内部更新。当我们切换 tab 标签时，可以看作是组件内部的交互行为，被\n选择后通过回调函数返回具体选择的索引。\n activeIndex 在外部更新。当我们切换 tab 标签时，可以看作是组件外部在传入具体的索\n引，而组件就像“木偶”一样被操控着。\n\n智能组件（smart component）和木偶组件（dumb component）。\n\n如何做到外部更新时让状态更新呢？\nprops\nReact 的单向数据流，主要的流动管\n道就是 props。props 本身是不可变的。当我们试图改变 props 的原始值时，React 会报出类型错\n误的警告，组件的 props 一定来自于默认属性或通过父组件传递而来。如果说要渲染一个对 props\n加工后的值，最简单的方法就是使用局部变量或直接在 JSX 中计算结果。\n\n假设 Tabs 组件的数据都是通过 data\nprop 传入的，即 <Tabs data={data} />。那么，Tabs 组件的 props 还会有哪些。\nclassName：根节点的 class。为了方便覆盖其原始样式，我们都会在根节点上定义 class\nclassPrefix：class 前缀。对于组件来说，定义一个统一的 class 前缀，对样式与交互\n分离起了非常重要的作用。\ndefaultActiveIndex 和 activeIndex：默认的激活索引，\nonChange：回调函数。当我们切换 tab 时，外组件需要知道组件内部的信息，尤其是当前\ntab 的索引号的信息。它一般与 activeIndex 搭配使用。\n\n\n")])])]),n("h1",{attrs:{id:"类式组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类式组件"}},[t._v("#")]),t._v(" 类式组件")]),t._v(" "),n("h2",{attrs:{id:"复习类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#复习类"}},[t._v("#")]),t._v(" 复习类")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tclass Person{\n\t\t//构造器\n\t\tconstructor(name,age){\n\t\t\t//构造器中的this---类的实例\n\t\t\tthis.name=name\n\t\t\tthis.age=age\n\t\t}\n\t\t//一般方法\n\t\t//speak放在存在哪里---类的原型对象\n\t\tspeak(){\n\t\t\tconsole.log(`我叫${this.name},我的年龄是${this.age}`)\n\t\t}\n\t}\n\n\t//创建实例\n\tconst p1 = new Person('tom',18)\n\tconst p2 = new Person('jack',20)\n\n\tconsole.log(p1) // Person{}  这里的意思是它是Person new出来的\n\tconsole.log(p2) // Person{}  这里的意思是它是Person new出来的\n\tp1.speak()\n\tp2.speak()\n\n\t怎么修改this\n\tcall\n\tapply\n\t...\n\n\t//创建一个Student类 继承Person类\n\tclass Student extends Person{\n\t\tconstructor(name,age,grade){\n\t\t\tsuper(name,age) //第一行！\n\t\t\tthis.grade=grade\n\t\t}\n\t}\n")])])]),n("h2",{attrs:{id:"函数式和类式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式和类式"}},[t._v("#")]),t._v(" 函数式和类式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("根据状态（state）有无状态分为\n\t简单组件（函数式）\n格式：\nfunction Mycomponent(){ \n    return 类似html结构\n}\n\n函数式组件和类式组件\n\t1. 函数式组件\n\n  function MyComponent (this: any){\n    console.log(this) //此处this 是undefined 因为babel开启了严格模式\n    return <h2>我是函数式组件</h2>\n  }\n\n使用时注意首字母大写\n<MyComponent/>\n\nReactDom.render(<Myconponent/>,document.getElementById('text'))\n注意：组件名首字母大写，自闭盒\n\t\n\t复杂组件（类式）\n格式：\nclass Mycomponent extends React.Component{\n\trender(){\n\t\treturn 类似html结构\n\t}\n}\nReactDom.render()\n")])])]),n("h2",{attrs:{id:"路由组件和普通组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由组件和普通组件"}},[t._v("#")]),t._v(" 路由组件和普通组件")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('  //1.创建类组件 继承React.Component\n  class MyClassComponent extends React.Component{\n    render(){\n      //render方法在哪里：在MyClassComponent原型对象上，供实例使用\n      //render中的this是谁：MyClassComponent的实例对象\n      console.log(this)\n      return <h2>我是类式组件</h2>\n    }\n  }\n\n  //2.渲染组件到页面\n  ReactDOM.render(<MyClassComponent/>,document.getElementById("test"))\n  \x3c!--\n  执行render后发生了什么？\n  1.React解析组件标签，找到MyClassComponent组件\n  2.发现组件是类定义的，随着实例调用原型的render方法\n  3.将render返回的虚拟dom转为真实dom 呈现到页面\n   --\x3e\n')])])]),n("h2",{attrs:{id:"受控组件和非受控组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#受控组件和非受控组件"}},[t._v("#")]),t._v(" 受控组件和非受控组件")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('## 受控组件\n\n\t页面中所有的输入类的dom，onChange事件，实时拿到最新值,存在状态里\n\t之后再发送请求，使用时，直接从state拿\n\t即vue的双向数据绑定\n\n\n\t//初始化state\n\tstate={\n\t\tusername: "",\n\t\tpassword: ""\n\t}\n\n\tsaveUsername= (e)=>{\n\t\tthis.setState({username:e.target.value})\n\t}\n\n\tsavePassword= (e)=>{\n\t\tthis.setState({password:e.target.value})\n\t}\n\t//表单提交的回调\n\thandleSubmit = (e)=>{\n\t\te.preventDefault() //阻止表单提交\n\t\t// const {username,password} = this\n\t\t// alert(`你输入的用户名是：${username},你输入的密码是：${password}`)\n\t}\n\n\trender(){\n\t\treturn(\n\t\t\t<form onSubmit={this.handleSubmit}>\n\t\t\t\t用户名：<input onChange={this.saveUsername} type="text" name="username"/>\n\t\t\t\t密码：<input onChange={this.savePassword} type="password" name="password"/>\n\t\t\t\t<button>登录<button/>\n\t\t\t</form>\n\t\t)\n\t}\n\n\n## 非受控组件\n\t页面中所有的输入类的dom，现用现取就是非受控组件\n\n\tclass Login extends React.component{\n\t\t//表单提交的回调\n\t\thandleSubmit = (e)=>{\n\t\t\te.preventDefault() //阻止表单提交\n\t\t\t// const {username,password} = this\n\t\t\t// alert(`你输入的用户名是：${username},你输入的密码是：${password}`)\n\t\t}\n\n\t\trender(){\n\t\t\treturn(\n\t\t\t\t<form onSubmit={this.handleSubmit}>\n\t\t\t\t\t用户名：<input ref={c => this.username = c} type="text" name="username"/>\n\t\t\t\t\t密码：<input ref={c => this.username = c} type="password" name="password"/>\n\t\t\t\t\t<button>登录<button/>\n\t\t\t\t</form>\n\t\t\t)\n\t\t}\n\t}\n\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);