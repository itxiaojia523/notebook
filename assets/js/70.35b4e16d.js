(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{475:function(n,e,t){"use strict";t.r(e);var o=t(2),a=Object(o.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("初级面试题\n1、HTML5的新特性？\n• 1、语义化标签，比如header、footer、nav、aside、article、section\n• 2、音视频，比如audio、video\n• 3、画布canvas、矢量图svg\n• 3、画布，canvas的api有getContext、fillStyle、fillRect等\n• 4、本地存储localStorage、sessionStorage\n• 5、web worker\n2、语义化的好处？\n• 1、代码分块清晰，便于维护\n• 2、页面结构清晰，便于浏览器。搜索引擎解析\n• 3、利于搜索引擎的爬取，利于SEO\n3、canvas的常用api有哪些？\n• getContext：返回一个指定canvas的绘画环境对象\n• beginPath：开始绘制\n• moveTo：移动画笔位置\n• lineTo：用来画线段\n• stroke：用来实施绘制的操作 上色\n• lineStyle：设置线段的样式\n• closePath：结束绘制\n4、web worker有什么作用？应用场景有哪些？\n开启一个子线程，且子线程的操作不受线程的影响\n• 大数据处理\n• 耗费时间较长的操作\n5、浏览器本地缓存localStorage与sessionStorage的区别？\n• 生命周期不同：前者一直存在浏览器，除非用户手动清除，后者生命周期结束于浏览器或者tab页的关闭\nCSS3\n1、有哪些新特性呢？\nflex、animation、transform、border-radius、box-shadow、opacity\n2、背景毛玻璃的效果如何实现呢？\nfilter：blur() 滤镜\n3、position有哪几种呢？\n• static：默认\n• relative：相对于自身\n• absolute：相对于最近的一个非static的祖先级元素进行定位\n• fixed：相对于屏幕窗口进行定位\n• sticky：用来实现吸顶效果\n4、如何自己实现跟position：sticky的效果？\n使用getBoundingClientRect或者IntersectionObserver计算指定元素位置，到达一定距离更改指定元素定位为fixed，从而实现sticky的效果\n5、重绘回流是什么呢？\n(https://juejin.cn/post/6986416221323264030\n6、怎么降低重绘回流的次数呢？\n文章链接 https://juejin.cn/post/6986416221323264030\n7、flex布局如何更改主轴方向？\n设置flex-direction样式属性\n8、flex布局如何允许换行呢？\n设置flex-wrap样式属性\n9、flex布局实现水平垂直据居中？\n设置justify-content和align-items都为center\n10、flex：1的原理是什么呢？\nflex-grow 、flex-shrink 、flex-basis这三个样式的合集，全写状态为flex:0 1 auto，简写为flex: 1\n11、rem与em的区别是什么呢？\n• rem：相对于")]),e("html",[n._v("标签的font-size去决定大小，例如html标签font-size为14px，则2rem === 28px\n• em：相对于自身的font-size去决定大小，自身没有font-size则继承祖先级元素的font-size\nJavaScript\n1、原型链是什么呢？有什么作用吗\n• 原型链：原型链是一条对象隐式原型不断往上指向的一条指向链，尽头是Object的隐式原型，也就是null\n• 实例的隐式原型proto = 构造函数的显示原型prototype\n• 变量看作用域 属性看原型链\n• 作用：构造函数原型上的东西可以让实例们共享，从而节省了空间\n2、闭包是什么？有什么优缺点\n闭包是一个能让函数外部访问到函数内部的一个函数\n• 优点是：延长函数内部变量的寿命，使函数外部能访问到函数内部\n• 缺点是：滥用闭包导致内存溢出，页面卡顿\n3、JavaScript总共有几种数据类型？\n字符串、布尔值、数值、undefined、null、object、symbol、bigInt\n4、JavaScript判断类型的方式是什么？\n• typeof：只能判断 字符串、布尔值、数值、undefined、function、object、symbol、bigInt，不能区分判断 数组、null、对象\n• A instanceof B：判断A是否为B的实例对象，从而判断A是否为B类型\n• Object.prototype.toString.call()：可以判断所有的数据类型\n6、JavaScript不同类型的存储方式有何区别？\n普遍认为\n• 基础数据类型存于栈内存\n• 引用数据类型存于堆内存 我认为\n• 所有数据都存于堆内存，栈内存只存指针\n7、你说字符串存储在栈内存，那如果字符串很长。超过了栈内存最大容量呢？\n所以说我觉得所有数据都存于堆内存，毕竟栈内存容量有限。\n8、call、apply、bind的区别？\n• call于apply的区别在于传参，前者直接传参，后者传一个数组\n• bind传参后不立即执行，而是会返回一个函数，这个函数可以继续传参，且执行（bind函数可以分两次传参）\n9、bind返回的函数能作为构造函数吗？\n不能哦，会报错的\n10、赋值、深拷贝与浅拷贝有什么不同？\n• 赋值：赋值指针指向，还是用的同一个内存空间\n• 浅拷贝：只拷贝第一层\n• 深拷贝：所有层都会进行拷贝\n11、怎么判断一个对象有环引用呢？\n定义一个空数组，且对于目标对象进行递归，每次都判断递归项是否为对象，是的话放进数组，且每次判断属性值是否在数组里，在的话说明环引用了\nfunction cycleDetector(obj) {\n   const arr = [obj]\n   let flag = false\n​\n   function cycle(o) {\n       const keys = Object.keys(o)\n       for (const key of keys) {\n           const temp = o[key]\n           if (typeof temp === 'object' && temp !== null) {\n               if (arr.indexOf(temp) >= 0) {\n                   flag = true\n                   return\n               }\n               arr.push(temp)\n               cycle(temp)\n           }\n       }\n   }\n​\n   cycle(obj)\n​\n   return flag\n}\nES6\n1、let、const的暂时性死区问题？\n在一个作用域里如果存在let、const定义的一个变量之前使用该变量，则报错“cannot access xx before initialization”\n2、Promise的then为什么可以链式调用？\nPromise的then方法返回一个新的Promise对象，保证了then方法可以进行链式调用\n3、async/await的用法？\n• async/await的作用是：以同步的方式执行异步操作，实现排队效果\n• async：async函数执行返回一个Promise\n• await：await后接Promise则会等待Promise返回结果，接普通函数执行则会接收返回结果\n• await只能在async中使用，但是浏览器调试中await可单独使用\n4、Class的静态属性、继承？\n• 静态属性：static关键字定义的变量属性，只能通过Class构造函数的属性的方式去访问\n• 继承：使用 Child extends Father {}，且配合super对象，完成继承\nVue\n1、Vue与React的区别在哪？\n比较的是Vue2 相同点：\n• 1.都使用了虚拟dom\n• 2.组件化开发\n• 3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)\n• 4.都支持服务端渲染 不同点：\n• 1.React的JSX，Vue的template\n• 2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty，Proxy)\n• 3.React单向绑定，Vue双向绑定\n• 4.React的Redux、mobx，Vue的Vuex、pinia\n2、computed与watch的区别？\n• computed：多对一，多个值的变化决定一个目标值的变化\n• watch：一对多，一个值的变化，引起多个目标值的变化\n3、Vue的生命周期介绍一下？"),e("p"),n._v(" "),e("p",[n._v("4、Vue的实例加载完成在哪个生命周期呢？\nbeforeCreated\n5、Vue的真实dom挂载完成在哪个生命周期呢？\nmounted\n6、数据更改如何获取最新DOM\nnextTick\n7、路由有几种模式，有何区别？\n• hash模式：监听url中hash的变化来实现不同页面的展示，链接带#\n• history模式：url中不带#，利用HTML5的history.pushState方法进行不刷新跳转页面，但需要后端配合404时的重定向\n• abstract：使用在非浏览器的环境，例如node环境\n8、路由有哪些钩子函数？\n全局钩子\n• beforeEach：跳转路由前\n• to：将要跳转进入的路由对象\n• from：将要离开的路由对象\n• next：一个方法，执行则完成跳转\n• afterEach：跳转路由后\n• to：将要跳转进入的路由对象\n路由独享钩子\nroutes: [\n{\n   path: '/xxx',\n   component: xxx,\n   beforeEnter: (to, from, next) => {\n     \n   }\n}\n]\n组件内路由钩子\n• beforeRouteEnter(to, from, next)：跳转路由渲染组件时触发\n• beforeRouteUpdate(to, from, next)：跳转路由且组件被复用时触发\n• beforeRouteLeave(to, from, next)：跳转路由且离开组件时出触发")]),n._v(" "),e("p",[n._v("重绘和回流\n1.解析html 构建dom树\n2.解析css 生成样式规则\n3.合并dom树和样式，生成渲染树\n4.布局render树，(layout, reflow) 这时候回流出现，负责各元素的尺寸，位置等的计算\n5.panting 绘制页面像素信息\n6.浏览器将各层信息发给GPU，GPU将各层合成，最后显示到屏幕上")]),n._v(" "),e("p",[n._v("什么是重绘和回流\n重绘：当页面元素样式不影响元素布局时（文档流中的位置）时，如background-color等\n浏览器只会将新的样式赋予给元素，并进行重绘")]),n._v(" "),e("p",[n._v("回流：当渲染树中的一部分或者全部因元素的尺寸，布局，隐藏等改变时，浏览器重新渲染部分DOM或全部DOM的过程")]),n._v(" "),e("p",[n._v("如何减少\n1.css中避免重绘和回流\n-尽可能在DOM树的最末端改变样式\n-避免设置多层内联样式\n-动画效果应用到position为absolute或fixed的元素上\n-避免使用table布局（它是一个整体）\n-使用css3硬件加速，可以让transform opcity filters等动画不会引起重绘\n2.js操作避免重绘和回流\n-尽量一次性修改完所有样式或者将样式定义好class：避免一个接着一个修改\n-避免频繁操作DOM，使用文档片断创建子树，然后拷贝到文档中\n-先隐藏元素，进行修改后再显示该元素，因为display:none 不会引起重绘和回流\n-避免循环读取offsetleft等属性，在循环之前把他们存起来\n-对于复杂动画效果，使用绝对定位让其脱离文档流")]),n._v(" "),e("p",[n._v("react\nhttps://juejin.cn/post/6941546135827775525上\nhttps://juejin.cn/post/6940942549305524238#heading-51\n高频前端面试题汇总之React篇（下）")]),n._v(" "),e("p",[n._v("useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("根据es6解构赋值，结构数组的时候，按顺序结构，可以别名\n\t\t\t结构对象的时，可以不按顺序，但是要跟内部名称对应\n")])])]),e("p",[n._v("React Hook 的使用限制有哪些？\n主要有两条：\n• 不要在循环、条件或嵌套函数中调用 Hook；\n• 在 React 的函数组件中调用 Hook。")]),n._v(" "),e("p",[n._v("useEffect 与 useLayoutEffect 的区别\n（1）共同点\n• 运用效果： useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。\n• 使用方式： useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。\n（2）不同点\n• 使用场景： useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。\n• 使用效果： useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。\n在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。")]),n._v(" "),e("p",[n._v("使用useState时候，使用push，pop，splice等直接更改数组对象的坑")]),n._v(" "),e("p",[n._v("使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题")]),n._v(" "),e("p",[n._v("（4）善用useCallback\n父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。")]),n._v(" "),e("p",[n._v("（5）不要滥用useContext\n可以使用基于 useContext 封装的状态管理工具")]),n._v(" "),e("p",[n._v("React Hooks 和生命周期的关系？")]),n._v(" "),e("p",[n._v("函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。 但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。\n即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。")]),n._v(" "),e("p",[n._v("在React中遍历的方法有哪些？")]),n._v(" "),e("p",[n._v("（1）遍历数组：map && forEach")]),n._v(" "),e("p",[n._v("（2）遍历对象：map && for in")]),n._v(" "),e("p",[n._v("在React中页面重新加载时怎样保留数据？\n这个问题就设计到了数据持久化， 主要的实现方式有以下几种：\n• Redux： 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；\n• data.js： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；\n• sessionStorge： 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据\n• history API： History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。\n为什么使用jsx的组件中没有看到使用react却需要引入react？\n本质上来说JSX是React.createElement(component, props, ...children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。\n在React中怎么使用async/await？\nasync/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。\n18. React.Children.map和js的map有什么区别？\nJavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。")]),n._v(" "),e("p",[n._v("反转数组arr.reverse()\n    // 反转数组  交换次数arr.length/2\n        var arr = [1,3,2,4]  // [4,2,3,1]\n        // 0    arr.length-1-0  进行交换\n        // 1    arr.length-1-1  进行交换\n        for(var i = 0; i < arr.length / 2; i++){\n            // 交换\n            var temp = arr[i]\n            arr[i] = arr[arr.length-1-i]\n            arr[arr.length-1-i] = temp\n        }\n        console.log(arr);")]),n._v(" "),e("p",[n._v("交换排序：冒泡排序 快速排序\n排序可以用arr的方法sort\narr.sort() //使得arr升序\narr.reverse() //反转数组\n        // 冒泡排序：基于交换将最大值冒到最左边或最右边 实现升序或降序\n        var arr = [5,4,3,2,1] //将其转化为升序排列\n        var length = arr.length\n        // 轮数i                 比较次数j\n        // 第一轮 4 3 2 1 5   4                          length - 1 - 0\n        // 第二轮 3 2 1 4 5   3  没必要再跟5比较了        length - 1 - 1\n        // 第三轮 2 1 3 4 5   2  同理3没必要再跟 4 5比    length - 1 -  2\n        // 第四轮 1 2 3 4 5   1  同理2没必要再3 4 5比     length - 1 - 3\n        // 第五轮 1 2 3 4 5   0  没必要进行第五轮         length - 1 - 4\n        //  轮数：4  length =arr.length = 5   i < length - 1\n        // 每次的次数   length - 1 - i\n        // 外循环是轮数\n        for(var i = 0; i < length - 1; i++){\n//可以设置一个flag = false 表是否交换\nflag = false\n            //内循环是次数\n            for(var j = 0; j< length - 1 - i; j++){\n                // 进行比较 如果前者大则交换\n                if(arr[j] > arr[j+1]){\n                    // 进行交换\n                    var temp = arr[j]\n                    arr[j] = arr[j+1]\n                    arr[j+1] = temp\nflag = true\n                }\nif(flag === false) return //如果不再交换，说明整体有序\n            }\n        }\n        function swap(a,b){\n                var temp = a\n                a = b\n                b = temp\n           \n        }\n        console.log(arr); // [1, 2, 3, 4, 5]\n算法\n  // 题目1\n        // 已知字符串get-element-by-id，要求写一个function 将其转化为驼峰表示法getElementById\n \n        var foo = 'get-element-by-id'\n        function toString(foo){\n        // 根据某个字符 分割字符串为数组\n            var arr = foo.split('-') //返回一个数组 [get,element,by,id]\n        // 将首字符首字母转为大写\n        // console.log(arr[1].charAt(0).toUpperCase()); // E\n        // 截取字符串 (起始索引值，结束索引值)\n        // console.log(arr[1].substr(1,arr[1].length -1 )); //lement")]),n._v(" "),e("p",[n._v("for(var i = 1; i < arr.length; i++){\n            arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1,arr[i].length -1 )\n        }\n        console.log(arr); // ['get', 'Element', 'By', 'Id']\n        // 根据某个字符 将数组连接为字符串\n        // 注意！ 不写的话，就是将数组转为字符串，会有,\n        console.log(arr.join()); //get,Element,By,Id\n        console.log(arr.join('')); //getElementById\n        return arr.join('')\n        }\n        foo = toString(foo)\n        console.log(foo);\n作用域\n  // 题目1\n        var num1 = 55\n        var num2 = 56\n        function fn1(num,num1){\n            // 函数参数会在函数内部声明提升\n            // var num = 55\n            // var num1 = 56\n            num = 100\n            num1 = 101\n            num2 = 102 //因为函数内部没有声明num2 此时这个num2指向全局的num2\n            console.log(num1);  // 101\n            console.log(num2); // 102\n            console.log(num); // 100\n        }\n        fn1(num1,num2) //调用并传入55 56\n        console.log(num1); // 55\n        console.log(num2); // 56 -> 102\n        console.log(num);  //报错   声明了没赋值才是undefined")]),n._v(" "),e("p",[n._v("// 题目2\n        // 声明一个Person构造函数\n        function Person (name,age,salary){\n            this.name = name\n            this.age = age\n            this.salary = salary\n        }\n        function fn1(person){\n            // var person = p 此时两者指向同一对象\n            person.name = 'maomao'\n            // person 指向新对象\n            person = new Person('binbin',18,10)\n        }\n        // 创建实例对象\n        var p = new Person('xiaopi',20,1000)\n        console.log(p.name); // 'xiaopi'\n        fn1(p)\n        console.log(p.name); // 'maomao'\njs预解析\nf1()\n    // console.log(a) //报错\n    console.log(b) //9\n    console.log(c) // 9\n    function f1(){\n      var a = b = c = 9\n//函数内部不加var b,c是全局变量\n      console.log(a) //9\n      console.log(b) // 9\n      console.log(c) //9\n    }")]),n._v(" "),e("p",[n._v("//相当于\n    // var c = 9 //函数内部不加var 是全局变量\n    // var b = 9\n    // function f1(){\n    //   var a\n    //   a = b\n    //   b = 9\n    //   c = 9\n    //   console.log(a) //9\n    //   console.log(b) //9\n    //   console.log(c) //9\n    // }\n    // f1()\n    // console.log(b) //9\n    // console.log(c) //9\n    // console.log(a) //报错")])])])}),[],!1,null,null,null);e.default=a.exports}}]);