(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{435:function(n,t,s){"use strict";s.r(t);var e=s(2),o=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("ECMA:european computer manufacturers association\nECMAScript 是根绝ECMA-262标准的脚本程序设计语言\n接口请求函数模块\n// 包含所有接口请求函数模块\n// 1.同一暴露\n// export default{\n//     xxx(){},\n//     yyy(){}\n// }\nimport ajax from './ajax'\n// 2.分别暴露 以req开头，方便\n// 登录\nexport function reqLogin(username,password){\n    return ajax('/api/user/login',{name:username,password},\"POST\")\n}\n// 添加用户\nexport const reqAddUser = (user)=> ajax('/api/user/add',user,\"POST\")\n\n兼容性查看\nkangax.github.io/compat-table/es6\n\n1.\nlet申明变量：可以批量申明并赋值\n！不能重复申明\n\n2.块级作用域 全局 函数 eval\n3.不存在变量提升\n4.不影响作用链 //不能由外向内找，作用域是由内向外，所以没关系\n\n申明常量const\n1.一定要赋初始值\n2.一般用大小\n3.值不能修改\n4.堆数组和对象的元素的修改，不会报错，因为地址没变\n\n解构赋值\n\t从数组和对象中提取值，堆变量进行赋值\n\tconst F4 = ['1','2','3','4']\n\tlet [yi,er,san,si] = F4\n\tconsole.log(yi) //1\n\n从对象提取值 \n注意：变量名=属性名\n  const zhao = {\n    name: 'caocao'\n  }\n  let {name} = zhao\n  console.log(name)\n\n新的声明字符串方式 反引号`` //tab上面\n\t内容中可以直接换行 之前需要'++'来连接\n\t直接拼接\nlet love = `毛毛`\nlet out = `${love}是我的最爱`\n\n简化对象的写法\n\t允许直接在大括号里直接写入变量，作为属性和方法\n\t  let name = 'mao'\n  let setName = function (name){\n    this.name = name\n  }\n  const maomao = {\n    name,\n    setName,\n    jump(){\n      console.log(`我能跳`)\n    }\n  }\n\n允许使用箭头来定义函数\n\t箭头 =>\n\tlet fn = () =>{}\n箭头函数特性\n\tthis是静态的，指向函数声明时所在作用域下的this\n\t不能作为构造函数\n\t不能使用arguments\n\t箭头函数的简写\n\t1.省略小括号，当形参只有一个时\n\t2.省略花括号，当代码体只有一句时，return也得省略\n\t\t返回值：为执行结果\n\n\nfilter()函数\nconst arr = [1,3,4,5,6]\nconst result = arr.filter(function(){\n\tif(item % 2 ===0 ){\n\treturn ture\n\t}else{\n\treturn false\t\n}\n})\t\t\nconsole.log(result) // 4 6\n或\nconst result = arr.filter(items => item % 2 === 0)\n\n箭头函数适用于\n\t1.与this无关的回调，定时器，数组的方法问题\n\t2.不适用与this有关的事件回调；对象的方法\n\n允许给形参赋初始值\n具有默认值的参数，一般放后\n\n与解构赋值组合\n\t\n\tconnect({\n\thost: 'localhost',\n\tusername\" 'root',\n\t})\nfunction connect(options){\n\tlet host = options.host; //每次都写options麻烦\n\tlet username = options.username \t\n}\n改为\nfunction connect(host = '127.0.0.1',username,password,port){\n\t\t\n}\n\n引入rest参数用于代替arguements\n\t作为参数时，要放最后\n\n\tfunction fn(a,b,...args){\n\tconsole.log(a)\n\tconsole.log(args)\t\n\t}\n\tfn(1,2,3,4,5)// a是1 b是2 args是[3,4,5]\n\n扩展运算符 ...\n\n\t能将数组转为逗号分割的 参数序列\n\nconst tf = ['毛','毛毛','毛毛毛']\n  function test(){\n    console.log(arguments)\n  }\n  test(tf)//0: (3) [\"毛\", \"毛毛\", \"毛毛毛\"]\n  test(...tf)//0: \"毛\" 1: \"毛毛\" 2: \"毛毛毛\"\n\n\t应用1：数组的合并\n  const tf = ['毛']\n  const kz = ['小','小小']\n  //合并数组tf和kz\n  const hebing = [...tf, ...kz]\n  console.log(hebing)//0: \"毛\" 1: \"小\" 2: \"小小\"\n\n\t应用2：数据的克隆 //浅拷贝，如果是地址值，指向同一对象\n  const kz = ['小','小小']\n  const  kelong = [...kz]\n  console.log(kelong)//0: \"小\" 1: \"小小\"\n\n\t应用3：将伪数组转为真正的数组\n  const divs = document.querySelectorAll('div')\n  console.log(divs)//nodelist里的proto是obj\n  const divArr = [...divs]\n  console.log(divArr) //0: div1: div\n\n新的原始数据类型symbol:表独一无二，类似字符串，值唯一，命名不会冲突\n\t不能与其他类型进行运算\n\t定义的对象属性不能用for in遍历\n\t用reflect.ownKeys获取所有键名\n\n  //创建symbol\n  let s1 = Symbol('毛'); //可以空，或者描述字符串，即注释\n  let s2 = Symbol('毛毛');\n  console.log(s1 === s2) //false\n  //创建symbol对象\n  let s3 = Symbol.for('毛毛');\n  let s4 = Symbol.for('毛毛')\n  console.log(s3 === s4) //true\n\n\t应用1：给对象添加属性或方法\n  //想给game对象添加up down相关的方法，但是直接添加up或down可能有命名冲突\n  let game = {\n    up: function () {\n      console.log('我是game的属性up')\n    },\n    //添加方式2\n    [Symbol('down相关')]: function () {\n      console.log('down')\n    }\n  }\n  let methods = {\n    up: Symbol('up相关'),\n    down: Symbol()\n  };\n  //添加方式1\n  game[methods.up] = function () {\n    console.log('我是新来的up')\n  };\n  console.log(game) //up: ƒ () Symbol(down相关): ƒ () Symbol(up相关): ƒ ()\n\nsymbol的内置值：symbol的属性\n\tex.Symbol.hasInstance 整体作为对象的属性\n\n  class Person{\n    static [Symbol.hasInstance](param){ //添加symbol.hasinstance 属性\n      console.log(param) //参数是调用instanceof 的对象\n      console.log('我被用于检测了，返回true吧')\n      return true\n    }\n  }\n  let o = {}\n  console.log(o instanceof Person)\n\n\n  const arr1 = [1,2]\n  const arr2 = [3,4]\n  console.log(arr1.concat(arr2)) // 1,2,3,4\n  arr2[Symbol.isConcatSpreadable] = false //不可展开，不可分开，只能作为整体\n  console.log(arr1.concat(arr2)) // [1,2,[3,4]]\n\n\n")])])]),t("h2",{attrs:{id:"import-and-export"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#import-and-export"}},[n._v("#")]),n._v(" import and export")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export 分别暴露\n1. export const App = ()=>{}\nimport {App} from xxx\n\nexport default分别暴露\n2. export default App\nimport App from xxx\n\n")])])]),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[n._v("#")]),n._v(" Promise")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('Promise是ES6 引入的异步编程的新解决方案。\n\n语法上Promise是一个构造函数\nconse p = new Promise(\n)\n\n接收一个函数作为参数，回调\n返回一个Promise\n  可以使用Promise的方法\n\t1. promise的then方法\n\t2. promise的catch方法\n\nex.\nconst p = new Promise( function(){\n\tsetTimeout(function(){\n\t\t//发送请求\n\t\tlet data = ""\n\t\tlet err = "数据读取失败"\n\t\tif(data 不为空…){\n\t\t\tresolve(data)//resolve表成功\n\t\t}else{\n\t\t\treject(err)//表失败\n\t\t}\n\t},1000)\n})\n\n//then方法可以接受两个函数作为参数\n第一个表成功时调用，第二个表失败时调用\np.then(function(value){\n\tconsole.log(value) //value = data resolve传过来的\n\t},function(reason){\n\tconsole.error(reason) // reason=err reject传来的\n})\n\n用catch可以只设置失败的情况\n封装时，可以同一catch 一次性处理err\np.catch(function(reason){\n  console.log(reason)\n})\n\n\n')])])]),t("h2",{attrs:{id:"解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[n._v("#")]),n._v(" 解构赋值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" // 解构赋值：从数组或对象中提取值，并赋值给变量\n        // 1.数组解构 []\n        let [a,b,c,d] = [1,2,3]; //注意 值有顺序对应关系\n        // console.log(a,b,c,d); 1 2 3 undefined 结构不到undefined\n        // 交换变量\n        let x = 1\n        let y = 2\n        x++\n        y++\n        [x,y] = [y,x]\n        //  let 声明的变量直到定义的代码被执行时才会初始化。在变量初始化前访问变量会导致 ReferenceError\n        console.log(x,y);\n        // 2.对象解构{}，变量必须有属性同名\n        let {foo , bar} = {foo:'tom', bar : 'mary'}\n        console.log(foo,bar);\n\n")])])]),t("h2",{attrs:{id:"模板字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串"}},[n._v("#")]),n._v(" 模板字符串``")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1.内容中可以出现换行符\nlet str = `<ul>\n          <li>TOM</li>\n          </ul>`\n\n2.拼接字符串 \n${} 取值\nlet out = `${value}是我认为最搞笑的演员！`\n")])])]),t("h2",{attrs:{id:"对象的简写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的简写"}},[n._v("#")]),n._v(" 对象的简写")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const school = {\n  name:name,\n  change:change,\n  improve:function(){\n    console.log("improves")\n  }\n}\n\n简写为：\nconst school ={\n  name, //key和value 名字相同\n  school,\n  improve(){\n    console.log("improve")\n  }\n}\n')])])]),t("h2",{attrs:{id:"async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[n._v("#")]),n._v(" async await")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("async 关键字为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 async，就可以使其成为一个异步函数。\n\nasync function myFunction() {\n  // 这是一个异步函数\n}\n\n在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 await 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。\n\nasync function fetchProducts() {\n  try {\n    // 在这一行之后，我们的函数将等待 `fetch()` 调用完成\n    // 调用 `fetch()` 将返回一个“响应”或抛出一个错误\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP 请求错误：${response.status}`);\n    }\n    // 在这一行之后，我们的函数将等待 `response.json()` 的调用完成\n    // `response.json()` 调用将返回 JSON 对象或抛出一个错误\n    const json = await response.json();\n    console.log(json[0].name);\n  }\n  catch(error) {\n    console.error(`无法获取产品列表：${error}`);\n  }\n}\nfetchProducts();\n\n这里我们调用 await fetch()，我们的调用者得到的并不是 Promise，而是一个完整的 Response 对象，就好像 fetch() 是一个同步函数一样。\n我们甚至可以使用 try...catch 块来处理错误，就像我们在写同步代码时一样。\n但请注意，这个写法只在异步函数中起作用。异步函数总是返回一个 Pomise\n\n所以你不能做这样的事情：\n\nasync function fetchProducts() {\n  try {\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP 请求错误：${response.status}`);\n    }\n    const json = await response.json();\n    return json;\n  }\n  catch(error) {\n    console.error(`无法获取产品列表：${error}`);\n  }\n}\nconst json = fetchProducts();\nconsole.log(json[0].name);   // json 是一个 Promise 对象，因此这句代码无法正常工作\n\n相反，你需要做一些事情，比如：\n\nasync function fetchProducts() {\n  try {\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP 请求错误：${response.status}`);\n    }\n    const json = await response.json();\n    return json;\n  }\n  catch(error) {\n    console.error(`无法获取产品列表：${error}`);\n  }\n}\nconst jsonPromise = fetchProducts();\njsonPromise.then((json) => console.log(json[0].name));\n\n")])])]),t("h2",{attrs:{id:"类中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类中的this"}},[n._v("#")]),n._v(" 类中的this")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    //constructor里的this指向实例对象\n    //方法里的this指向调用者\n")])])]),t("h2",{attrs:{id:"let-和-const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const"}},[n._v("#")]),n._v(" let 和 const")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1.变量不能重复命名\n2.块级作用域 （es5：全局 局部 eval(严格模式)）\n3.不存在变量提升\n4.不影响作用域链\n\nconst 申明常量\n1.一定要赋初始值\n2.一般大写SCHOOL\n3.常量的值不能改\n4.块级作用域\n5.对数组和对象的元素修改，不算对常量的修改（地址值）\n")])])]),t("h2",{attrs:{id:"箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("()=>{}\n\n声明一个函数\nlet fn = function(){}\n\nlet fn = ()=>{}\n1.this是静态的，指向声明时所在作用域的this\n2.箭头函数 不能作为构造函数\n3.不能用arguments（用rest）\n\n箭头函数的省略\nlet pow = n => n*n\n\n1.省略(),当形参有且只有一个\n2.省略{}和return,当代码体只有一条语句，且该语句的执行结果就是函数的返回值\n\n应用场景\n1.适用于与this无关的回调，定时器，数组方法的回调等\n2.不适合作为this有关的回调，事件回调，对象的方法\n\nex.\n需求：返回偶数\nconst arr = [1,3,5,6,8,9]\nconst result = arr.filter(item => item%2 ===0)\n")])])]),t("h2",{attrs:{id:"es7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es7"}},[n._v("#")]),n._v(" es7")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Array.prototype.includes\nconst arr = [1,3,4,5]\narr.includes(3) //返回boolean\n\n指数运算符 ** 实现幂运算\nconsole.log(2 ** 10) 相当于 Math.pow(2,10)\n")])])]),t("h2",{attrs:{id:"函数参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数参数"}},[n._v("#")]),n._v(" 函数参数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('1.形参可以赋初始值,一般位置靠后(潜规则)\n//为什么靠后：因为如果放b的位置，有实参2个的话，第二个直接顶掉了，意义不大\nfunction add(a,b,c=10){\n  return a+b+c\n}\nadd(1,2)\nadd(1,2,3)\n\n2.与解构赋值结合\nfunction connect(options){\n  let host = options.host\n  let username = options.username\n}\n\nconnect({\n  host:"localhost",\n  username:"root"\n  password:"root",\n  port:3306\n})\n\n---\x3e\nfunction connect({\n  host="127.0.0.1",\n  username,\n  password,\n  port:3306\n}){\n  //可以直接拿来用\n  console.log(host)\n  console.log(username)\n  console.log(password)\n  console.log(port)\n}\nconnect({\n  host:"localhost",\n  username:"root"\n  password:"root",\n  port:3306\n})\n\n')])])]),t("h2",{attrs:{id:"rest-参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest-参数"}},[n._v("#")]),n._v(" rest 参数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('es5获取实参方式\nfunction date(){\n  console.log(arguments) //得到一个对象\n  }\n\nes6\n\nfunction date(...args){\n  console.log(args) //得到一个数组，可以用数组的API\n}\n\ndate("阿娇","白纸","恩惠")\n\n//rest参数必须放到最后\nfunction fn(a,b,...args){\n  console.log(a)\n  console.log(b)\n  console.log(args)\n}\n\nfn(1,2,3,4,5,6) \n// 1,2,[3,4,5,6]\n\n')])])]),t("h2",{attrs:{id:"扩展运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[n._v("#")]),n._v(" 扩展运算符")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('es6\n能够将数组转为逗号分隔的参数序列\nconst tfboys = ["易烊千玺","王俊凯","愿望"]\n// => "易烊千玺","王俊凯","愿望"\n\nfunction fn(){\n  console.log(arguments)\n}\nfn(...tfboys) // fn("易烊千玺","王俊凯","愿望")\n\nes9 对象可使用拓展运算符\nfunction connect({\n  host,port,...uesr\n}){}\n\nconnect({\n  host:"127.0.0.1",\n  port: 3306,\n  username:"root",\n  password:"root",\n  type:"master"\n})\n\n//对象合并\nconst skillOne={\n  q:"拍地板"\n}\nconst skillTwo={\n  w:"位移"\n}\n\nconst skill = {...skillOne,...skillTwo}\n\n//如果原先有name,则会替换\nlet person3 = {...person,name:"jack"} \n\n')])])]),t("h2",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[n._v("#")]),n._v(" Symbol")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('新的数组类型：表独一无二的值\n//创建symbol\n//1. 调用Symbol创建\nlet s = Symbol()\n//console.log(s,typeof s)\nlet s2 = Symbol("小贾")\nlet s3 = Symbol("小贾")\n// console.log(s2 === s3) //false\n\n//2.Symbol.for创建\nlet s4 = Symbol.for("小贾")\nlet s5 = Symbol.for("小贾")\n// console.log(s4 === s5) // true\n\n1.不能与其他数据进行运算\nlet result = s + 100;\n\n')])])]),t("h2",{attrs:{id:"迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[n._v("#")]),n._v(" 迭代器")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("迭代器\n\t为不同数据结构提供统一的访问机制\n\t任何数据结构，部署迭代器interator接口，就可以完成遍历操作\n  es6新的遍历命令for of,迭代器接口主要供for of消费\n  使用for of 遍历\n原生具备interator接口的数据\n\tarray arguments set map string typedarray nodelist\n\njs中的迭代器接口就是对象中的一个属性symbol.iterator\n\n\n  const arr1 = ['mao','maomao','maomaomao']\n  for (let v in arr1) {\n    console.log(v) // 0 1 2 键名\n  }\n  for (let x of arr1) {\n    console.log(x) // mao maomao maomaomao 键值\n  }\n\n迭代器应用-自定义遍历数据\n  const banji = {\n    name: 'class1',\n    stus: [\n      'mao',\n      'maomao',\n    ],\n    [Symbol.iterator](){ //当被for of遍历时调用\n      //4.什么索引遍历\n      let index = 0\n      let _this = this // banji\n      return { //1.返回一个指针对象\n        next: function () { //2.添加一个next方法\n          if (index < _this.stus.length){\n            const result = {value: _this.stus[index], done: false} //3. next方法的返回值 是一个对象\n            index++\n            return result\n          }else {\n            return {value: undefined, done: true};\n          }\n        }\n      };\n    }\n  }\n  //需求：遍历这个对象，且返回stus这个数组中的value for in 返回的是key\n  //banji.stus.forEach() 这是遍历数组\n  //遍历这个对象\n  for (let s of banji){\n    console.log(s)\n  }\n\n生成器：是一个函数，解决异步编程\n")])])]),t("h2",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[n._v("#")]),n._v(" Set")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("新的数据结构Set\n类似数组，但是成员值唯一，不能重复\n属性和方法\n.size\nadd\ndelete\nhas\nclear 清空集合\n\ntype是Object\n\nlet s = new Set()\nlet s2 = new Set([1,1,2,2,3])\n\nconsole.log(s2) // [1,2,3] 初始值是可迭代的话，会去重\n\n1. 数组去重\n\n2. 交集\n3. 并集\n4. 差集\n")])])]),t("h2",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[n._v("#")]),n._v(" Map")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("新的数据结构,键值对形式\n但是key不局限于string\n方法和属性几乎同Set\n\n\n")])])]),t("h2",{attrs:{id:"class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[n._v("#")]),n._v(" Class")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('es6的class只是一个语法糖，只是让对象原型的写法更清晰，更面向对象编程\n1. class声明类\n2. constructor\n3. extends\n4. super\n5. static\n6. 重写\n\nex.\n\nclass Phone{\n  constructor(brand,price){\n    this.brand = brand\n    this.price = price\n\n    //方法必须这么写\n    call(){}\n  }\n}\n\nlet iphone6 = new Phone("Apple",80000)\n\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);