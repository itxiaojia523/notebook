(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{431:function(n,t,o){"use strict";o.r(t);var e=o(2),i=Object(e.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"必包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#必包"}},[this._v("#")]),this._v(" 必包")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("\n产生条件，函数嵌套且内部函数引用了外部函数变量，执行外部函数\n\n什么是必包\n是一个内部函数的对象，含有被引用变量\n\n作用：延长局部变量生命周期，\n         使得外部能操作内部的变量\n将函数作为返回值\n将函数作为实参\n定义模块\n\n遍历+监听\nfor(var i = 0;i <btns.length; i++){}\n\nfor(var i = 0, length = btns.length;i <length; i++){}\n第二种写法性能更好，length只计算一次\n\nfor(var i = 0, length = btns.length;i <length; i++){\n    var btn = btns[i]\n    btn.onclick = function (){\n      alert('第'+(i+1)+'个') //一直是4\n    }\n  }\nconsole.log(i) /3\n1.遍历完了以后 才执行函数\n2.所以要给btn加一个下标\n    var btn = btns[i]\n//将btn所对应的下标保存在btn上\n    btn.index = i\n    btn.onclick = function (){\n      alert('第'+(this.index+1)+'个') \n    }\n\n闭包\nfor(var i = 0, length = btns.length;i <length; i++){\n      (function (i){\n        var btn = btns[i]\n        btn.onclick = function (){\n          alert('第'+(i+1)+'个')\n        }\n      })(i)\n}\n\n如何产生闭包\n1.嵌套的函数\n2.内部函数，引用了父函数的变量\n3.执行外部函数\n注意：不用调用内部函数，仅调用外部函数 就产生了\n\n  function f1(){\n    var a = 2\n    var b = 3\n    function fn2() {\n      console.log(a)\n    }\n  }\n  f1()\n没引用b 所以闭包里没有b\n\n什么是闭包\n理解1：是嵌套的内部函数（大多数人）\n理解2：是包含被引用变量的对象（在内部函数中） 少数人 通过chrome debug程序查看\n\n常见的闭包\n1.将函数作为另外一个函数的返回值\nfunction f1(){\n    var a = 2\n    function fn2() {\n      a++\n      console.log(a)\n    }\n    return fn2\n}\nvar f = fn1() //如果没有闭包 fn1执行，a就没了，执行f，就报错了\n//这说明在反复执行函数的过程中 闭包中的数据没有消失！\nf()// a = 3\nf()// a = 4\nf = null //让闭包变成垃圾对象，死亡\n\n2.将函数作为实参传递给另外一个函数\n  function showDelay(msg, time){\n    setTimeout(function (){\n      alert(msg)\n    },time)\n  }\n  showDelay('maomao',2000)\n\n闭包的作用\n1.保存局部变量（函数执行完后，仍存在内存中，延长了局部变量的生命周期）\n2.在外部操作局部变量\n\n闭包的应用\n1.定义JS模块 myModule\n\t-JS文件\n\t-将所有函数和功能封装在一个函数中\n\t-只向外暴露一个或多个方法的对象\n;function myModule(){\n  var msg = 'maomao'\n  function doSomething(){\n    console.log('doSomething()' + msg.toUpperCase())\n  }\n  function doOtherthing() {\n    console.log('doOtherthing' + msg.toLowerCase())\n  }\n  //向外暴露对象，给外部使用的方法\n  return {\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  }\n}\nvar module = myModule()\nmodule.doSomething()\n\n或（推荐，更直接）\n;(function myModule(){\n  var msg = 'maomao'\n  function doSomething(){\n    console.log('doSomething()' + msg.toUpperCase())\n  }\n  function doOtherthing() {\n    console.log('doOtherthing' + msg.toLowerCase())\n  }\n  //向外暴露对象，给外部使用的方法\n  window.myModule2 = {\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  }\n})()\nmyModule2.doSomething()\n\n最终版\n;(function myModule(window){\n  var msg = 'maomao'\n  function doSomething(){\n    console.log('doSomething()' + msg.toUpperCase())\n  }\n  function doOtherthing() {\n    console.log('doOtherthing' + msg.toLowerCase())\n  }\n  //向外暴露对象，给外部使用的方法\n  window.myModule2 = {\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  }\n})(window)\n如果没定义参数，不能压缩为w，与代码压缩相关\n\n闭包的缺点\n\t1.函数内局部变量没有释放，占用内存事件会变长\n\t2.容易造成内存泄漏\n解决\n\t1.能不用就不用\n\t2.及时释放 即f = null\n\n内存溢出与内存泄漏\n内存溢出：\n\t当一个程序运行需要的内存超过剩余的内存空间，就出现内存溢出的错误\n\t导致程序出现错误\n内存泄漏：\n\t占用的内存没有及时释放\n\t内存泄漏积累多了就容易导致内存溢出\n\n常见的内存泄漏\n\t意外的全局变量 函数内部 a = 3（全局） 与 var a = 3 （局部）\n\t没有及时清理的计时器或回调函数  clearInterval\n\t闭包\t\tf = null\n\nvar name = 'The Window'\n  var obj = {\n    name: 'My Obj',\n    getName: function () {\n      return function () {\n        return this.name\n      }\n    }\n  }\n  alert(obj.getName()())//相当于这个函数直接调用 function(){}(),this是window\n\n\nvar name = 'The Window'\n  var obj = {\n    name: 'My Obj',\n    getName: function () {\n      var that = this\n      return function () {\n        return that.name\n      }\n    }\n  }\n  alert(obj.getName()())  //that 是getName的this，this就是obj\n！常用，将一个函数的this用变量存起来，最后用\n\nfunction fun(n,o) {\n    console.log(o)\n    return {\n      fun: function (m){\n        return fun(m,n)\n      }\n    }\n  }\n  var a = fun(0);//undefined 此时return一个对象，闭包产生n=0\n  a.fun(1) 0 //m =1  return fun(1,0)；执行fun(1,0) 输出0，\n\t新的闭包产生，但是立刻消失，没有接受return的结果\n  如果是\n  var xxx = a.fun(1) //此时n=1\n  a.fun(2) 0\n  a.fun(3) 0\n\n\n  var b = fun(0).fun(1).fun(2).fun(3) //undefined 0 1 2\n  var c = fun(0).fun(1) undefined 0 \n  c.fun(2) //1\n  c.fun(3) //1\n\n 分析：o=n 即闭包的值\n关注有没有产生新的闭包\n")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);