(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{468:function(t,a,e){"use strict";e.r(a);var r=e(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、todolist案例相关知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、todolist案例相关知识点"}},[t._v("#")]),t._v(" 一、todoList案例相关知识点")]),t._v(" "),a("p",[t._v("1.拆分组件、实现静态组件，注意：className、style的写法\n        2.动态初始化列表，如何确定将数据放在哪个组件的state中？\n                    ——某个组件使用：放在其自身的state中\n                    ——某些组件使用：放在他们共同的父组件state中（官方称此操作为：状态提升）\n        3.关于父子之间通信：\n                1.【父组件】给【子组件】传递数据：通过props传递\n                2.【子组件】给【父组件】传递数据：通过props传递，要求父提前给子传递一个函数\n        4.注意defaultChecked 和 checked的区别，类似的还有：defaultValue 和 value\n        5.状态在哪里，操作状态的方法就在哪里")]),t._v(" "),a("h2",{attrs:{id:"二、github搜索案例相关知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、github搜索案例相关知识点"}},[t._v("#")]),t._v(" 二、github搜索案例相关知识点")]),t._v(" "),a("p",[t._v("1.设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。\n        2.ES6小知识点：解构赋值+重命名\n                    let obj = {a:{b:1}}\n                    const {a} = obj; //传统解构赋值\n                    const {a:{b}} = obj; //连续解构赋值\n                    const {a:{b:value}} = obj; //连续解构赋值+重命名\n        3.消息订阅与发布机制\n                    1.先订阅，再发布（理解：有一种隔空对话的感觉）\n                    2.适用于任意组件间通信\n                    3.要在组件的componentWillUnmount中取消订阅\n        4.fetch发送请求（关注分离的设计思想）\n                    try {\n                        const response= await fetch("),a("code",[t._v("/api1/search/users2?q=${keyWord}")]),t._v(")\n                        const data = await response.json()\n                        console.log(data);\n                    } catch (error) {\n                        console.log('请求出错',error);\n                    }")]),t._v(" "),a("h2",{attrs:{id:"三、路由的基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、路由的基本使用"}},[t._v("#")]),t._v(" 三、路由的基本使用")]),t._v(" "),a("p",[t._v("1.明确好界面中的导航区、展示区\n            2.导航区的a标签改为Link标签\n                        "),a("Link",{attrs:{to:"/xxxxx"}},[t._v("Demo")]),t._v("\n            3.展示区写Route标签进行路径的匹配\n                        "),a("Route",{attrs:{path:"/xxxx",component:"{Demo}/"}},[t._v("\n            4."),a("App",[t._v("的最外侧包裹了一个"),a("BrowserRouter",[t._v("或"),a("HashRouter")],1)],1)],1)],1),t._v(" "),a("h2",{attrs:{id:"四、路由组件与一般组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、路由组件与一般组件"}},[t._v("#")]),t._v(" 四、路由组件与一般组件")]),t._v(" "),a("p",[t._v("1.写法不同：\n                        一般组件："),a("Demo"),t._v("\n                        路由组件："),a("Route",{attrs:{path:"/demo",component:"{Demo}/"}},[t._v('\n            2.存放位置不同：\n                        一般组件：components\n                        路由组件：pages\n            3.接收到的props不同：\n                        一般组件：写组件标签时传递了什么，就能收到什么\n                        路由组件：接收到三个固定的属性\n                                            history:\n                                                        go: ƒ go(n)\n                                                        goBack: ƒ goBack()\n                                                        goForward: ƒ goForward()\n                                                        push: ƒ push(path, state)\n                                                        replace: ƒ replace(path, state)\n                                            location:\n                                                        pathname: "/about"\n                                                        search: ""\n                                                        state: undefined\n                                            match:\n                                                        params: {}\n                                                        path: "/about"\n                                                        url: "/about"')])],1),t._v(" "),a("h2",{attrs:{id:"五、navlink与封装navlink"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、navlink与封装navlink"}},[t._v("#")]),t._v(" 五、NavLink与封装NavLink")]),t._v(" "),a("p",[t._v("1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名")]),t._v(" "),a("h2",{attrs:{id:"六、switch的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、switch的使用"}},[t._v("#")]),t._v(" 六、Switch的使用")]),t._v(" "),a("p",[t._v("1.通常情况下，path和component是一一对应的关系。\n                2.Switch可以提高路由匹配效率(单一匹配)。")]),t._v(" "),a("h2",{attrs:{id:"七、解决多级路径刷新页面样式丢失的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、解决多级路径刷新页面样式丢失的问题"}},[t._v("#")]),t._v(" 七、解决多级路径刷新页面样式丢失的问题")]),t._v(" "),a("p",[t._v("1.public/index.html 中 引入样式时不写 ./ 写 / （常用）\n                2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）\n                3.使用HashRouter")]),t._v(" "),a("h2",{attrs:{id:"八、路由的严格匹配与模糊匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、路由的严格匹配与模糊匹配"}},[t._v("#")]),t._v(" 八、路由的严格匹配与模糊匹配")]),t._v(" "),a("p",[t._v("1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）\n                2.开启严格匹配："),a("Route",{attrs:{exact:"{true}",path:"/about",component:"{About}/"}},[t._v("\n                3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由")])],1),t._v(" "),a("h2",{attrs:{id:"九、redirect的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、redirect的使用"}},[t._v("#")]),t._v(" 九、Redirect的使用")]),t._v(" "),a("p",[t._v("1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由\n                2.具体编码：\n                        "),a("Switch",[a("Route",{attrs:{path:"/about",component:"{About}/"}},[a("Route",{attrs:{path:"/home",component:"{Home}/"}},[a("Redirect",{attrs:{to:"/about"}})],1)],1)],1)]),t._v(" "),a("h2",{attrs:{id:"十、嵌套路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、嵌套路由"}},[t._v("#")]),t._v(" 十、嵌套路由")]),t._v(" "),a("p",[t._v("1.注册子路由时要写上父路由的path值\n                2.路由的匹配是按照注册路由的顺序进行的")]),t._v(" "),a("h2",{attrs:{id:"十一、向路由组件传递参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、向路由组件传递参数"}},[t._v("#")]),t._v(" 十一、向路由组件传递参数")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("1.params参数\n                            路由链接(携带参数)："),a("Link",{attrs:{to:"/demo/test/tom/18"}},[t._v("详情")]),t._v("\n                            注册路由(声明接收)："),a("Route",{attrs:{path:"/demo/test/:name/:age",component:"{Test}/"}},[t._v("\n                            接收参数：this.props.match.params\n                2.search参数\n                            路由链接(携带参数)："),a("Link",{attrs:{to:"/demo/test?name=tom&age=18"}},[t._v("详情")]),t._v("\n                            注册路由(无需声明，正常注册即可)："),a("Route",{attrs:{path:"/demo/test",component:"{Test}/"}},[t._v("\n                            接收参数：this.props.location.search\n                            备注：获取到的search是urlencoded编码字符串，需要借助querystring解析\n                3.state参数\n                            路由链接(携带参数)：\n"),t._v("\n                            注册路由(无需声明，正常注册即可)："),a("Route",{attrs:{path:"/demo/test",component:"{Test}/"}},[t._v("\n                            接收参数：this.props.location.state\n                            备注：刷新也可以保留住参数")])],1)],1)],1),t._v(" "),a("h2",{attrs:{id:"十二、编程式路由导航"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十二、编程式路由导航"}},[t._v("#")]),t._v(" 十二、编程式路由导航")]),t._v(" "),a("p",[t._v("借助this.prosp.history对象上的API对操作路由跳转、前进、后退\n                            -this.prosp.history.push()\n                            -this.prosp.history.replace()\n                            -this.prosp.history.goBack()\n                            -this.prosp.history.goForward()\n                            -this.prosp.history.go()")]),t._v(" "),a("h2",{attrs:{id:"十三、browserrouter与hashrouter的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十三、browserrouter与hashrouter的区别"}},[t._v("#")]),t._v(" 十三、BrowserRouter与HashRouter的区别")]),t._v(" "),a("p",[t._v("1.底层原理不一样：\n                        BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。\n                        HashRouter使用的是URL的哈希值。\n            2.path表现形式不一样\n                        BrowserRouter的路径中没有#,例如：localhost:3000/demo/test\n                        HashRouter的路径包含#,例如：localhost:3000/#/demo/test\n            3.刷新后对路由state参数的影响\n                        (1).BrowserRouter没有任何影响，因为state保存在history对象中。\n                        (2).HashRouter刷新后会导致路由state参数的丢失！！！\n            4.备注：HashRouter可以用于解决一些路径错误相关的问题。")]),t._v(" "),a("h2",{attrs:{id:"十四、antd的按需引入-自定主题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十四、antd的按需引入-自定主题"}},[t._v("#")]),t._v(" 十四、antd的按需引入+自定主题")]),t._v(" "),a("p",[t._v('1.安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader\n            2.修改package.json\n                    ....\n                        "scripts": {\n                            "start": "react-app-rewired start",\n                            "build": "react-app-rewired build",\n                            "test": "react-app-rewired test",\n                            "eject": "react-scripts eject"\n                        },\n                    ....\n            3.根目录下创建config-overrides.js\n                    //配置具体的修改规则\n                    const { override, fixBabelImports,addLessLoader} = require(\'customize-cra\');\n                    module.exports = override(\n                        fixBabelImports(\'import\', {\n                            libraryName: \'antd\',\n                            libraryDirectory: \'es\',\n                            style: true,\n                        }),\n                        addLessLoader({\n                            lessOptions:{\n                                javascriptEnabled: true,\n                                modifyVars: { \'@primary-color\': \'green\' },\n                            }\n                        }),\n                    );\n                4.备注：不用在组件里亲自引入样式了，即：import \'antd/dist/antd.css\'应该删掉')])])}),[],!1,null,null,null);a.default=s.exports}}]);