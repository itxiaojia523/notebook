(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{433:function(n,r,e){"use strict";e.r(r);var t=e(2),a=Object(t.a)({},(function(){var n=this,r=n._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"创建数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建数组"}},[n._v("#")]),n._v(" 创建数组")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("tips: 建议使用数组字面量方式【简单】\n1.\n  //利用new关键字    \n  var arr = new Array(); \n\t注意：括号里只写一个数，表长度；多个数表内容\n  var colors = new Array('red','blue')\n2.\n  //*利用数组字面量（推荐）\n  var colors = [];\n  var arr = ['小黑','小白','小黄','小兰'] （推荐）\n")])])]),r("h2",{attrs:{id:"遍历数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#遍历数组"}},[n._v("#")]),n._v(" 遍历数组")]),n._v(" "),r("p",[n._v("将数组里的元素从头到尾访问一次，可对其中逐个元素进行操作")]),n._v(" "),r("h3",{attrs:{id:"for循环遍历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#for循环遍历"}},[n._v("#")]),n._v(" for循环遍历")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("var arr = ['星期一','星期二','星期三','星期四','星期五','星期六','星期日']\nfor (i = 0; i < arr.length;i++){\n  console.log(arr[i])\n}\n")])])]),r("h3",{attrs:{id:"es5定义了5个迭代方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es5定义了5个迭代方法"}},[n._v("#")]),n._v(" ES5定义了5个迭代方法")]),n._v(" "),r("h3",{attrs:{id:"tips"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tips"}},[n._v("#")]),n._v(" tips：")]),n._v(" "),r("p",[n._v("map、forEach里不可以使用continue、break ,每一项都会执行，如果遍历中要用到continue或break提升效率，则可以使用for()循环 或 for...of..循环")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  每个方法接收2个参数\n      要在每一项上运行的函数 | 运行该函数的作用域对象（可选）\n\n  运行的函数包括3个参数 \n      [数组项的值 | 该项在数组中的位置 | 数组对象本身\n")])])]),r("h3",{attrs:{id:"array-prototype-every"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-every"}},[n._v("#")]),n._v(" Array.prototype.every()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  检查数组中的项是否满足某个条件\n  每一项都返回true,则返回true\n  var nums = [1,2,3,4,5,4,3,2,1]\n  nums.every((item, index, arr)=> item >2 ) //false\n\n")])])]),r("h3",{attrs:{id:"array-prototype-some"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-some"}},[n._v("#")]),n._v(" Array.prototype.some()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  检查数组中的项是否满足某个条件\n  数组中某一项返回true,则返回true\n  var nums = [1,2,3,4,5,4,3,2,1]\n  nums.some((item, index, arr)=> item >2 ) //true\n")])])]),r("h3",{attrs:{id:"array-prototype-foreach"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-foreach"}},[n._v("#")]),n._v(" Array.prototype.forEach()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  对数组中的每一项运行给定函数，这个方法没有返回值\n  //返回nums中每一项乘以2的数组\n  var nums = [1,2,3,4,5,4,3,2,1]\n  nums.forEach((item, index, arr)=> item * 2 ) // undefined\n")])])]),r("h3",{attrs:{id:"array-prototype-map"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-map"}},[n._v("#")]),n._v(" Array.prototype.map()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  返回每次函数调用的返回值组成的新数组\n  ex.\n  //返回nums中每一项乘以2的数组\n  let nums = [1,2,3,4,5,4,3,2,1]\n  nums.map((item, index, self)=> item * 2 ) // [2, 4, 6, 8, 10, 8, 6, 4, 2]\n")])])]),r("h3",{attrs:{id:"array-prototype-filter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-filter"}},[n._v("#")]),n._v(" Array.prototype.filter()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v(" 返回true的项组成的新数组\n  ex.\n  //返回nums中所有值大于2的数组\n  let nums = [1,2,3,4,5,4,3,2,1]\n  nums.filter((item, index, arr)=> item >2 ) //[3, 4, 5, 4, 3]\n")])])]),r("h3",{attrs:{id:"array-prototype-find"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-find"}},[n._v("#")]),n._v(" Array.prototype.find()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("返回第一个true的项，全部不匹配返回undefined\n\n  [1,4,9,10,15].find((item, index, arr)=>{\n      return item > 9;\n  }) //10\n  [1,4,9,10,15].findIndex((item, index, arr)=>{\n      return item > 10;\n  }) //4\n")])])]),r("h3",{attrs:{id:"array-prototype-reduce"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-reduce"}},[n._v("#")]),n._v(" Array.prototype.reduce()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  arr.reduce(function（PRE,CUR,INDEX,ARR）=> ({}) , {})\n  reduce接收两个参数\n    1.函数：4个参数[前一个值 | 当前值 | 项的索引 | 数组对象本身]\n    2.初始值\n\n  默认从左开始\n  //求数组所有元素之和\n  var nums = [1,2,3,4,5]\n  nums.reduce((prev,cur,index,arr)=>prev+cur) //15\n\n  arr.reduceRight()\n  从右开始\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\n  //计算每个元素出现的次数\n        // {name: 1, age: 2, GENDER: 3}\n        let arr = ['name','age','age','GENDER','GENDER','GENDER']\n        let result = arr.reduce((pre,cur) => {\n            if(!pre[cur]){\n                pre[cur] = 1\n            }else{\n                pre[cur]++\n            }\n            return pre\n        },{})\n        console.log(result);\n\n        // 字符转出现最多的字符，出现了几次\n        const find = (str)=>{\n            // 字符串转数组 [...str]\n            const map = [...str].reduce((pre,cur)=>{\n                if(!pre[cur]){\n                    pre[cur] = 1\n                }else{\n                    pre[cur]++\n                }\n                return pre\n            },{})\n            // console.log(map); {h: 1, e: 1, l: 2, o: 1}\n            // 将对象转为数组，这是一个二维数组\n            // console.log(Object.entries(map)); 0: (2) ['h', 1]\n            // 数组的解构赋值\n            const [[chart,count]] = Object.entries(map).sort(([,val1],[,val2])=> val2 -val1)\n            // console.log(arr); 0: (2) ['l', 2]\n            // console.log(chart,count); l 2\n            return {\n                chart,\n                count\n            }\n        }\n        console.log(find('hello'));\n\n数组的交集，补集和并集 \n  const arrOne = [1,2,3]\n        const arrTwo = [2,3,4,5]\n        //数组交集 [2,3]\n        const intersectionFn = (arr1,arr2)=>{\n            // filter 返回true的项组成的新数组\n            const result = arr1.filter(item1 => {\n                // some 检查数组中的项是否满足某个条件 数组中某一项返回true,则返回true\n                return arr2.some(item2 => {\n                    return item2 === item1\n                })\n            })\n            console.log('交集',result);\n            return result\n        }\n        intersectionFn(arrOne,arrTwo)\n        //数组补集 arr2的补集\n        const completeFn = (arr1,arr2)=>{\n            // every 检查数组中的项是否满足某个条件 每一项都返回true,则返回true\n            const result = arr1.filter( item1 => arr2.every( item2 => item2 !== item1))\n            console.log('arr2的补集',result);\n            return result\n        }\n        completeFn(arrOne,arrTwo)\n        //数组并集 [1,2,3,4,5]\n        const unionFn = (arr1,arr2)=>{\n            //concat\n            //没有传递参数，那么只是复制当前数组并返回副本，原数组不变；\n            //传递一个元素（数组）或多个元素（数组）,会将其合并到arr中，返回新数组，原数组不变\n            const result = arr1.filter( item1 => arr2.every( item2 => item2 !== item1)).concat(arr2)\n            console.log('并集',result);\n            return result\n        }\n        unionFn(arrOne,arrTwo)\n\n  \n")])])]),r("h2",{attrs:{id:"判断是否为空数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断是否为空数组"}},[n._v("#")]),n._v(" 判断是否为空数组")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const isEmpty = (arr) => Array.isArray(arr) && !arr.length;\n")])])]),r("h2",{attrs:{id:"检测变量是否为数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#检测变量是否为数组"}},[n._v("#")]),n._v(" 检测变量是否为数组")]),n._v(" "),r("h3",{attrs:{id:"isarray-推荐"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#isarray-推荐"}},[n._v("#")]),n._v(" isArray() 推荐")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("能检测iframes 更优一些 IE9+\n最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的，这个方法的用法如下。\nif（Array.isArray(value)）{\n    return true;\n}\n")])])]),r("h3",{attrs:{id:"object-prototype-tostring"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-tostring"}},[n._v("#")]),n._v(" Object.prototype.toString")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("如果在尚未实现isArray方法的浏览器中准确监测数组,我们需要用到Object.prototype.toString方法来判断，每一个继承自Object的对象都拥有toString的方法。\nif(!Array.isArray){\n    Array.isArray = function(arg){\n        return Object.prototype.toString.call(arg)==='[object Array]'\n    }\n}\n\n自己可以封装一个获取变量类型的函数\nfunction getType(obj) {\n    return Object.prototype.toString.call(obj).slice(8,-1);\n}\n\nvar a = [1,2,3];\nconsole.log(getType(a)); //Array \n\nvar b = function(){};\nconsole.log(getType(b)); //Function\n\n\n")])])]),r("h3",{attrs:{id:"typeof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typeof"}},[n._v("#")]),n._v(" typeof")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('对于一些基本类型，typeof是可以判断出数据类型，但是判断一些引用类型时候，不能具体到具体哪一种类型\n\n// 基本类型\ntypeof 123;  //number\ntypeof "123"; //string\ntypeof true; //boolean\ntypeof undefined; //undefined\ntypeof null; //object\nlet s = Symbol;\ntypeof s; //symbol\n\n// 引用类型\ntypeof [1,2,3]; //object\ntypeof {}; //object\ntypeof function(){}; //function\ntypeof  Array; //function  Array类型的构造函数\ntypeof Object; //function  Object类型的构造函数\ntypeof Symbol; //function  Symbol类型的构造函数\ntypeof Number; //function  Number类型的构造函数\ntypeof String; //function  String类型的构造函数\ntypeof Boolean; //function  Boolean类型的构造函数\n')])])]),r("h3",{attrs:{id:"instanceof-和-constructor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-和-constructor"}},[n._v("#")]),n._v(" instanceof 和 constructor")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("两种简单，但是不是十分准确的方法\n\nvar obj = [4,67,23];\nobj instanceof Array; //return true \nobj.constructor == Array; // return true\n\n复习一下instanceof用法\n1. 判断一个实例是否属于某种类型\nfunction Foo(name) {\n    this.name = name;\n}\nvar f = new Foo('zhangsan');\nconsole.log(f instanceof Foo); //true\nconsole.log(f instanceof Object); //true\n\n2. 判断一个实例是否属于它的父类型\nfunction Person() {};\nfunction Student() {};\nvar p = new Person();\nStudent.prototype = p;\nvar s = new Student();\nconsole.log(s instanceof Student); //true\nconsole.log(s instanceof Person); //true\n\ninstanceof 判断逻辑？\nf instanceof Foo 的判断逻辑是：f的__proto__一层层往上是否能对应到Foo.protoType\n\n判断逻辑翻译成js代码如下：\n_instanceof(f, Foo);  \n\nfunction _instanceof(L, R) {\n    var R = R.prototype;\n    var L = L.__proto__;\n    while( true) {\n        if(L == null) {\n            return false;\n        }\n        if(L == R) {\n            return true;\n        }\n        L = L.__proto__;\n    }\n}\n\ninstanceof 不准确的原因?\n\n    var iframe = document.createElement('iframe');\n    document.body.appendChild(iframe);\n\n    var arr = [1,2,3];\n    xArray = window.frames[0].Array;  //iframe中的构造函数\n    var arrx = new xArray(4,5,6);\n\n    console.log(arrx instanceof Array);  //false\n    console.log(arrx.constructor == Array);// false\n\n    console.log(Array.prototype == xArray.prototype); //false\n    console.log(arr instanceof xArray); //false\n\n    console.log(arrx.constructor === Array);// false\n    console.log(arr.constructor === Array);// true\n    console.log(arrx.constructor === xArray);// true\n    console.log(Array.isArray(arrx));  //true\n\n解释：红宝书，p88\ninstanceof操作符的问题在于，它假定只有一个全局环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。\n如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。\n\nconstructor 不准确的原因?\n因为constructor可以被重写，所以不能确保一定是数组\n    var str = 'abc';\n    str.constructor = Array;\n    str.constructor === Array // return true\n而很明显str不是数组。\n而且constructor和instanceof存在同样问题，不同执行环境下，constructor判断不正确问题。\n")])])]),r("h3",{attrs:{id:"json-stringify"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify"}},[n._v("#")]),n._v(" JSON.stringify()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const obj = {}\nconsole.log(JSON.stringify(obj) === '{}') //true 将对象转换为字符串比较\n")])])]),r("h3",{attrs:{id:"object-keys"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-keys"}},[n._v("#")]),n._v(" Object.keys()")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const obj = {}\n//Object.keys()将对象中可枚举的属性取出来，以数据形式返回\nconsole.log(Object.keys(obj).length === 0)//true\n")])])]),r("h3",{attrs:{id:"for-in"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#for-in"}},[n._v("#")]),n._v(" for...in")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("//原理:循环对象,如果进入循环(说明对象不为空),如果不进入循环,说明是空对象\nfunction isEmptyObj(obj) {\n  for (let k in obj) {\n    return false\n  }\n  return true\n}\n\nconst re = isEmptyObj({})\nconsole.log(re)  //true\n\n")])])]),r("h2",{attrs:{id:"新增数组元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新增数组元素"}},[n._v("#")]),n._v(" 新增数组元素")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\t//1.修改length长度\n      var arr = [2,6,1,7,4,77,52,25]\n      arr.length = arr.length + 3;\n      console.log(arr)\n      console.log(arr[11]) //undefined 只加了坑位，新加坑位没有值所以是undefined\n\t//2.新增数组元素\n      var arr = [2,6,1,7,4,77,52,25]\n      arr[11] = 11\n      console.log(arr) //直接往第12个坑位赋值11，arr[10]的话因为在中间，没值也是undefined\n")])])]),r("h2",{attrs:{id:"数组元素增删的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组元素增删的方法"}},[n._v("#")]),n._v(" 数组元素增删的方法")]),n._v(" "),r("p",[r("strong",[n._v("会修改原数组")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("push、pop、unshift、shift\n\narr.push(item)\n接受任意数量的参数，添加到数组末尾，返回新数组的长度\nvar colors = ['red']\ncolors.push('blue','green'); //3\n\narr.pop()\n删除数组最后一项，返回删除的项\nvar colors = ['blue','green']\ncolors.pop() //green\n\narr.unshift()\n接受任意数量的参数，添加到数组头部，返回新数组的长度\nvar colors = ['red']\ncolors.unshift('green') //2\n\narr.shift()\n删除数组第一项，返回删除的项\nvar colors = ['blue','green']\ncolors.shift() //blue\n\n")])])]),r("h2",{attrs:{id:"数组排序方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组排序方法"}},[n._v("#")]),n._v(" 数组排序方法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("1.revers() //翻转\n2.sort() //冒泡排序，从小到大；注意是按每个数的最高位排序\n var arr = [22,4,3,33,111,1]\n console.log(arr.sort()) // 1,111,22,3,33,4\n解决方法：\n  console.log(arr.sort(function (a, b){\n  return a - b //表升序  b -a 表降序\n  })) \n")])])]),r("h2",{attrs:{id:"数组索引方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组索引方法"}},[n._v("#")]),n._v(" 数组索引方法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("1. indexOf() //给定元素的索引号,只会返回第一个满足条件的索引号；如果找不到返回-1\n2. lastIndexOf() //从后往前找，索引号的顺序不会变，简单了解就行了\n")])])]),r("h2",{attrs:{id:"数组去重"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组去重"}},[n._v("#")]),n._v(" 数组去重")]),n._v(" "),r("p",[n._v("核心算法：遍历旧数组，与新数组对比")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\tvar arr1 = [22,4,3,33,111,1,2,2,2,2,3,3,3,33,1,11,111]\n    function unique(arr){\n      var newArr = []\n      for (var i = 0; i < arr.length; i++){\n        if (newArr.indexOf(arr[i]) === -1){\n          newArr.push(arr[i])\n        }\n      }\n      return newArr\n    }\n    var result =  unique(arr1)\n    console.log(result)\n")])])]),r("h2",{attrs:{id:"将数组转化为字符串"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#将数组转化为字符串"}},[n._v("#")]),n._v(" 将数组转化为字符串")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("1. toString // arr.toString() // 1,2,3\n2. join(分隔符) // arr.join('&') // 1&2&3\n")])])]),r("h2",{attrs:{id:"其他数组对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其他数组对象"}},[n._v("#")]),n._v(" 其他数组对象")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("1. concat() // 连接多个数组，返回新数组\n2. slice(begin,end) // 返回截取的新数组\t\n3. splice(第几个开始，要删除的个数) //返回被删除后的新数组；注意会影响原数组 \n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("## 转换方法\narr.valueOf()\nvar colors = ['red','blue','green']\ncolors.valueOf() //['red','blue','green']\n\narr.toString()\nvar colors = ['red','blue','green']\ncolors.toString() //\"red,blue,green\"\n\ntips: arr.toString() 与 arr.join()输出相同，不过join里可以输入其它链接符\n\n\n\nreverse、sort、concat、slice\nsort扩展(非数字类型排序，对象里的某个key值排序)\n\narr.concat()\n没有传递参数，那么只是复制当前数组并返回副本，原数组不变；\n传递一个元素（数组）或多个元素（数组）,会将其合并到arr中，返回新数组，原数组不变\nvar colors = ['red','blue','green']\ncolors.concat('gray',['a','green'])  //[\"red\", \"blue\", \"green\", \"gray\", \"a\", \"green\"]\nconsole.log(colors) // [\"red\", \"blue\", \"green\"]\ntips: js数组复制\n [...arr]   //ES6\nArray.from(arr) //ES6\n$.extend(arr) //JQ\n\n\n查找元素\narr.indexOf(searchValue, [start])\n验证数组中是否含有某个元素，返回第一个匹配到的元素在数组中所在的位置，如果没有，则返回 -1\n第二个参数是起始位置 0 到 length -1 \nvar colors =  [\"red\", \"gray\", \"yellow\"]\ncolors.indexOf('gray') // 1\ncolors.indexOf('mm') //-1\narr.lastIndexOf()\n验证数组中是否含有某个元素，不过是从数组尾部开始查找，返回第一个匹配到的元素所在的位置，如果没有，则返回-1\nvar colors =  [\"red\", \"gray\", \"yellow\",\"gray\"]\ncolors.indexOf('gray') // 3\ncolors.lastIndexOf('mm') //-1\n\nES6数组方法扩展\n1、求一个数组中最大元素\n由于js不提供求数组最大元素的函数，所以只能套用Math.max函数将数组转为一个参数序列，然后求最大值；有了扩展运算符以后就可以直接使用了Math.max了\n//ES5的写法\nMath.max.apply(null,[1,3,6]) ///6\n//ES6的写法\nMath.max(...[1,3,6]) //6\n2、通过push函数将一个数组添加到另一个数组的尾部\nES5的写法中，push的参数不可以是数组，所以只好通过apply方法变通使用push方法；有了扩展运算符，可以直接将数组传入push方法中\n//ES5的写法\nvar arr1 = [1,2]\nvar arr2 = [4,5]\nArray.prototype.push.apply(arr1,arr2) //返回新数组长度，arr1改变\n//ES6的写法\nvar arr1 = [1,2]\nvar arr2 = [4,5]\narr1.push(...arr2) //返回新数组长度，arr1改变\n3、合并数组\n//ES5写法\nvar arr = [4,5]\n[1,2].concat(arr) //[1, 2, 4, 5]\n//ES6写法\nvar arr = [4,5]\n[1,2,...arr]\n4、Array.from()妙用\n//数组去重\nfunction combine(){ \n    let arr = []..apply([], arguments);  //没有去重复的新数组 \n    return Array.from(new Set(arr));\n} \nvar m = [1, 2, 2], n = [2,3,3]; \nconsole.log(combine(m,n)); // [1, 2, 3]\n//遍历Nodelist对象\nlet ps = document.querySelectorAll('p')\nArray.from(ps).forEach(function(p){\n    console.log(p)\n})\n//将字符串转化为数组\nArray.from('hello') //[\"h\", \"e\", \"l\", \"l\", \"o\"]\n5、Array.of()\n替代Array() 或 new Array(),并且不存在参数不同而导致的重载\nArray.of(2,3,5) //[2,3,5]\nArray.of(2) //[2]\nArray.of(2).length //1\n6、arr.copyWithin()\n将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变\n接收三个参数[从该位置开始替换 | 从该位置开始读取数据 | 到该位置停止读取数据]\n//将4,5移动到前两位\n[1,2,3,4,5].copyWithin(0,3) //[4,5,3,4,5]\n8、arr.fill()\n用给定的值填充一个数组\n['a','b','c'].fill(7) //[7,7,7]\n['a','b','c'].fill(7,1,2) //['a',7,'c']\n9、arr.includes()\n数组是否包含某个值，返回true 或 false\n[1,2,3].includes(2) //true\n10、for...of...\n遍历数组元素\nfor(let item of colors){\n    console.log(item) // red,gray,yellow\n}\ntips:里面可以使用break continue提升效率\nJquery方法\n$.each(arr, fn)\n遍历数组或者对象，fn有2个参数，分别为， 比原生的for in 更加健壮\n[ 数组的索引或者对象的key值 | 索引或者key值对应的value值 ]\nvar arr = [1, 2, 3];\n$.each(arr, function(key, value) {\n    // do something\n});\ntips:跳过一次循环 return | return true 终止循环 return false\n$.grep(arr, fn)\n过滤方法，功能类同原生中的arr.filter(fn)。此处fn的参数如下\n[ value: 对象/数组的值 | key值或者序列 ]\nvar arr = [ 1, 3, 6, 4 ];\n$.grep(arr, function(val, key) {\n    return val >= 3;\n});\n// > [3, 6, 4]\n// arr : [ 1, 3, 6, 4 ] 不会改变\n$.map(arr, fn)\n对每项进行处理，返回处理结果组成的数组，此处fn的参数如下\n[ value: 对象/数组的值 | key值或者序列 ]\nvar arr = [1, 2, 5, 3];\n$.map(arr, function(val, key) {\n    return val * 10;\n})\n// > [10, 30, 30, 20, 10]\n// 原数组不受影响\n$.inArray(item, array)\n检测某一个元素item是否存在与数组之中，返回其所在的位置，如果不在，则返回-1\n$.inArray(3, [1, 2, 3]);\n// > 2\n$.merge(arr1, arr2)\n合并数组，会改变第一个参数的数组为合并之后的数组，返回合并之后的数组\nvar arr = [1, 3, 4];\nvar arr2 = [4, 3, 1];\n$.merge(arr, arr2);\n// > [1, 3, 4, 4, 3, 1]\n// 为了防止第一个数组被改变，可以使用下面的方式来写\n$.merge($.merge([], arr), arr2);\n$.unique(arr)\n过滤DOM数组中重复的元素\n$.makeArray(obj)\n将类数组对象转换为数组\n$(elem).toArray()\n将jQuery对象集合恢复成DOM数组\n")])])]),r("h2",{attrs:{id:"数组方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组方法"}},[n._v("#")]),n._v(" 数组方法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("// arr.slice(start,end)\n// 剪切数组，返回剪切之后的数组，不改变原数组\n// 1、传入一个参数，表示起始位置，结束位置为最末尾\nvar colors = ['red','blue','green']\ncolors.slice(2) //['green']\n// 2、传入2个参数，表示起始位置与结束位置，但不包括结束位置所在的元素\ncolors.slice(1,2) //['blue']\n\n// arr.splice(startIndex,deleteCount,item) 返回删除元素组成的数组，原数组变了\n// [起始位置（ 数组下标） | 要删除的项数 为0 | 要插入的元素]\n// tips:这个方法会因为参数的不同而实现不同的功能\n// 1.删除：arr.splice(startIndex, deleteCount)\n// 传入两个参数，第一个为位置（ 数组下标），第二个为删除的项数，可以删除任意项，\nvar colors = ['red','blue','green']\ncolors.splice(1,1) //['blue']\n//2.添加元素 删除项数为0\nvar colors = ['red','blue','green']\ncolors.splice(1,0,'gray') //[]\nconsole.log(colors) // ['red','gray','blue','green']\n//3.替换元素\nvar colors = [\"red\", \"gray\", \"blue\", \"green\"]\ncolors.splice(2,2,'yellow') // [\"blue\", \"green\"]\nconsole.log(colors); //[\"red\", \"gray\", \"yellow\"]\n\n数组迭代和reduce归并\n\n\n\n\n\n//当数组的数据是对象时，要利用对象的属性来判断\n        const classOne = [\n            {userId:1, name:'小赵'},\n            {userId:2, name:'Tom'},\n            {userId:3, name:'Mary'}\n        ]    \n        const classTwo = [\n            {userId:2, name:'Tom'},\n            {userId:3, name:'Mary'},\n            {userId:4, name:'小张'}\n        ]       \n        const intersectionFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.some(item2 => item2.userId === item1.userId))\n            console.log('交集',result);\n            return result\n        }   \n        intersectionFn(classOne,classTwo)\n        const completeFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.every(item2 => item2.userId !== item1.userId))\n            console.log('arr2的补集',result);\n            return result\n        }   \n        completeFn(classOne,classTwo)\n        const unionFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.every(item2 => item2.userId !== item1.userId)).concat(classTwo)\n            console.log('并集',result);\n            return result\n        }   \n        unionFn(classOne,classTwo)\n\n数组排序sort，reverse\n\narr.reverse()\n反转数组的顺序，并返回重新排序之后的数组， 原数组会被改变\nvar arr1 = [1,2,3,'red','blue']\narr1.reverse() //[\"blue\", \"red\", 3, 2, 1]\n\narr.sort()\n如果不传参数，默认情况下数组内的元素会被转换为字符串进行比较，因此一般不推荐直接使用默认的arr.sort()进行排序。\n\n返回值排序后的新数组。原数组会被改变\n注意：sort里接收一个比较函数 \nvar b = [1,2,3]\n//升序\nb.sort((a,b)=>a-b) //[1, 2, 3]\n//降序\nb.sort((a,b)=>b-a) //[3, 2, 1]\n\n数组求和以及斐波那契数列\n    const data = [1,2,3,4]\n        const sum = (arr)=>{\n            let result = 0\n            for( let i = 0; i<arr.length; i++){\n                result = arr[i] + result\n            }\n            console.log('合计',result);\n            return result\n        }\n        sum(data)\n        // 斐波那契数列 F(0) = 0 F(1) = 1 F(2)=1 F(n) = F(n-1) = F(n-2) n>= 2 n属于正整数\n        // 当前数 = 前两位数之和\n        // 目标：问第几项，得到那一项的值\n        // 1.递归的方法 - 性能缺陷\n        const getValue = (n)=>{\n            if(n < 2){\n                return n\n            }\n            return getValue(n-1) + getValue(n-2)\n        }\n        console.log('递归',getValue(3));\n        // 2.动态规划\n        const dynamicGetValue = (n)=>{\n            if(n < 2){\n                return n\n            }\n            let numArr = [0,1]\n            // for循环变量 性能高\n            for(let i = 2; i<= n; i++){\n                numArr.push(numArr[0] + numArr[1]) //[0, 1, 1]\n                // 删除：splice(index, num)\n                // 传入两个参数，第一个为位置（ 数组下标），第二个为删除的项数，可以删除任意项，返回删被除元素组成的数组，原数组变了\n                // 传入3个参数， [起始位置（ 数组下标） | 要删除的项数 为0 | 要插入的元素]， 最终返回被删除掉的元素组成的数组，因为这里删除项数为0，因此会返回空数组\n                numArr.splice(0,1) //[1, 1]\n            }\n            return numArr[1]\n        }\n        console.log('动态',dynamicGetValue(2));\n\n简单：数组和等于目标值\n\n   const data = [\n            {userId: 1, name:'小明', chineseScore: 90, mathScore: 90},\n            {userId: 2, name:'小往', chineseScore: 80, mathScore: 90},\n            {userId: 3, name:'小张', chineseScore: 70, mathScore: 90},\n            {userId: 4, name:'小李', chineseScore: 60, mathScore: 90},\n            {userId: 5, name:'小白', chineseScore: 50, mathScore: 90},\n        ]\n        // 找出成绩高于170的学生\n        const filterStudent = (arr,target)=>{\n            let result = []\n            for(let i = 0; i < arr.length; i++){\n                if(arr[i].chineseScore + arr[i].mathScore >= target){\n                    result.push(arr[i].name)\n                }\n            }\n            console.log(result);\n            return result\n        }\n        filterStudent(data,170) \n        // 给定一个数组,给定一个目标值，返回数组内满足条件的下标组合\n        const nums = [3,2,7,11,15]\n        const findTarget = (nums,target)=>{\n            let result = {}\n            for(let i = 0; i < nums.length; i++){\n                for(let j =0; j < nums.length; j++){\n                    if(nums[i] + nums[j] === target){\n                        return { index:[i,j], value:[nums[i],nums[j]]}\n                    }\n                }\n            }\n        }\n        let result = findTarget(nums,9)\n        console.log(result);\n\n数组去重for filter set\n\n  // 数组去重\n        //1.for循环嵌套\n\t      / / 借助新数组，如果原数组中的值 与其重复则不插入\n        var arr = [8,11,11,13,14,14,15]\n        var newArr = []\n        newArr[0] = arr[0]\n        // arr中每个元素\n        for(var i =0 ; i< arr.length; i++){\n            // 新数组中每个元素\n            for(var k =0; k < newArr.length; k++){\n                // 如果有相同得，没必要继续内循环\n                if(arr[i] === newArr[k]){\n                    break\n                }\n                // 直到比到新数组最后一项，才知道是否要插入\n                if(k === newArr.length -1 ){\n                    newArr.push(arr[i])\n                }\n            }\n        }\n        console.log(newArr);\n\n\t或\n\t        var arr = [8,11,11,13,14,14,15]\n\t        const forRemoveDuplicate = (arr)=>{\n\t            for(let i =0 ; i< arr.length; i++){\n\t                for( let j = i+1; j< arr.length; j++){\n\t                    if(arr[i] === arr[j]){\n\t                        arr.splice(j,1)\n\t                        j--\n\t                    }\n\t                }\n\t            }\n\t            return arr\n\t        }\n\t        let result = forRemoveDuplicate(arr)\n\t        console.log(result);\n\t\n\t//filter去重\n\t        const forRemoveDuplicate = (arr)=>{\n\t            // 返回true的项组成的新数组\n\t            return arr.filter((item,index,self)=>{\n\t                // indexOf 第一个匹配到的元素的位置\n\t                return self.indexOf(item) === index\n\t            })\n\t        }\n\t//es6 set去重\n\t        var arr = [8,11,11,13,14,14,15,16]\n\t        const es6RemoveDuplicate = (arr)=>{\n\t            return Array.from(new Set(arr))\n\t        }\n\t        let result = es6RemoveDuplicate(arr)\n\t        console.log(result);\n\n将对象类型数据转为数组对象\n    const data = {\n            beijing:100,\n            shanghai : 60,\n            guangzhou: 80\n        }\n        // (3) [{…}, {…}, {…}]\n            // 0: {name: 'beijing', value: 100}\n            // 1: {name: 'shanghai', value: 60}\n            // 2: {name: 'guangzhou', value: 80}\n        const objToArr = (data, realName, realValue)=>{\n            // console.log(Object.keys(data)); //['beijing', 'shanghai', 'guangzhou']\n            const res = Object.keys(data).map((key)=>{\n                return{ [realName]: key, [realValue]:data[key] }\n            })\n            console.log(res);\n            return res\n        }\n        objToArr(data,'name','value')\n数组对象转为普通对象\n  const data1 = [ //二维数组  \n            ['key1','value1'],\n            ['key2','value2']\n        ]\n        console.log(Object.fromEntries(data1));\n        // {key1: 'value1', key2: 'value2'}\n\n\n        // 数组对象转为普通对象\n        const data = [\n            {name: 'beijing', value: 100},\n            {name: 'shanghai', value: 60},\n            {name: 'guangzhou', value: 80}\n        ]\n        //     {\n        //     beijing:100,\n        //     shanghai : 60,\n        //     guangzhou: 80\n        //      }\n        const arrToObj = (data,realName,realValue)=>{\n            // 返回每次函数调用的结果组成的新数组\n            const res = data.map((item)=>{\n                return [ item[realName], item[realValue]]\n            })\n            console.log(res); //得到二维数组\n            return Object.fromEntries(res)\n        }\n        let result = arrToObj(data,'name','value')\n        console.log(result);\n数据分组处理\n\n   // 根据年级表和学生表，生成学生对象\n        const gradeList = [\n            { grade1: '一年级'},\n            { grade2: '二年级'},\n            { grade3: '三年级'}\n        ]\n        const studentList = [\n            { grade1: ['小明','小郑','小张']},\n            { grade2: ['阿毛','阿毛毛','阿阿毛']},\n            { grade3: ['tom','jacj','jerry']}\n        ]\n        // 想得到\n        // students = [\n        //     {name : '小明' ,grade : '一年级'}\n        // ]\n        const parseDataFn = (data, gradeList)=>{\n            let result = []\n            for ( let i = 0; i < data.length; i++){\n                const item = data[i] // grader1 [...]\n\t\t\t//for in 用于循环对象\n                for (const key in gradeList[i]) {\n                    console.log(key); // grade1\n                    for( let j = 0; j < item[key].length; j++){\n                        const nameValue = item[key][j] // 拿到每个学生名字 小明，小张...\n                        result.push({name : nameValue, grade: gradeList[i][key]}) \n                    }\n                }\n            }\n            console.log(result);\n            return result\n        }\n        parseDataFn(studentList,gradeList)\n数组，字符串at方法 取最后一个元素\n  // 数组，字符串at方法 取最后一个元素\n    const arr = [1,2,3,4]\n    console.log(arr.at(-1)); // 4 倒一\n    console.log(arr.at(-2)); // 3 倒二\n处理小数点位数\n根据num获取它的小数点位数\n0.1 -> 1位\n\n    const getDecimal = (num)=>{\n      let len = 0\n      if(Math.floor(num) === num){\n        //如果是整数\n        return 0\n      }\n      // 利用字符串的substr方法\n      // var str=\"Hello world!\";\n      // var n=str.substr(2,3)  //llo\n      const str = String(num)\n      const pointIndex = str.indexOf('.') //小数点下标 \n      console.log(str.substr(pointIndex + 1)); //得到小数点后的数字的 str  \n      len = str.substr(pointIndex + 1).length\n      console.log(len);\n      return len\n    }\n    getDecimal(0.12342)\n数字加法运算\n // 数字加法，把小数转为整数运算 再除回去\n    console.log(0.1+0.2); //0.30000000000000004\n    console.log(1+2); //3 \n\n    const add = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = n1Len > n2Len ? n1Len : n2Len\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const maxTimes = Math.pow(10, maxLen) \n      console.log(maxLen, maxTimes); // 1 10\n      result = (n1 * maxTimes + n2 * maxTimes) / maxTimes\n      console.log(result);\n      return result\n    }\n    add(9,0.0002)\n数字乘法\n// 数字乘法\nconsole.log(1 * 2); //2 \nconsole.log(0.1 * 0.2); //0.020000000000000004\n      const mulFn = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = n1Len > n2Len ? n1Len : n2Len\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const n1Times = Math.pow(10, n1Len)\n      const n2Times = Math.pow(10, n2Len)\n      result = (n1 * n1Times) *( n2 * n2Times) / (n1Times * n2Times)\n      console.log(result);\n      return result\n    }\n    mulFn(0.9,2)\n数字除法\nconsole.log(0.01 / 0.2); // 0.049999999999999996\nconsole.log(0.1 / 0.2); // 0.5\n    const divisionFn = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = Math.max(n1Len,n2Len)\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const maxTimes = Math.pow(10, maxLen)\n      result = (n1 * maxTimes) / (n2 * maxTimes)\n      console.log(result);\n      return result\n    }\n    divisionFn(1,22)\nMath对象常用方法\n// Math对象相关方法\nconsole.log(Math.ceil(12.1) ); //13  向上取整\nconsole.log(Math.floor(12.1) ); // 12 向下取整\nconsole.log(Math.round(12.5) ); //13 四舍五入\nMath.max() //求最大值\nMath.pow(4,3) //求mi  4的三次方\nMath.abs() //求绝对值\n\n检测变量类型toString()\n // toString 功能\n    // 1. 转化为字符串\n    const num = 123;\n    console.log('将数字转为字符串', num.toString());\n    // 2.返回一个表示该对象的字符串\n    // Object.prototype.toString.call()  通过call调用原型上的toString(防止重写)\n    console.log(Object.prototype.toString.call(num) ); //[object Number]\n    //第一个值表示Object 没啥含义\n    //第二个值 表表示该对象的字符串 \ntoString()方法-检测变量类型\n  // object.prototype.toString.call()\n    const num = 321\n\t//toString 返回一个表示该对象的字符串\n    console.log(Object.prototype.toString.call(num)); //[object Number] 可以知道是number\n\nXXX.toString() // xxx就是object\n\n获取对象深层次的值\n    // 获取对象深层次的值\n        let res = {\n            status : 0,\n            msg: 'success',\n            data: {\n                config: {\n                    // style : {\n                    //     color: '#000'\n                    // }\n                    style : null\n                }\n            }\n        }\n        \n        // console.log(res.data.config.style.color); \n        // 如果其中有一个环节是null就会报错\n        // 取一个值之前要判断是否存在 方法1\n        // console.log(res.data && res.data.config && res.data.config.style && res.data.config.style.color); \n        // 方法2 配置选择符\n        console.log(res.data?.config?.style?.color); //注意遇到null会返回undefined \n        // 在哪里改?\n        // 方法3 safeGet函数 问题同二\n        const safeGet = (obj,path)=>{\n            const keys = path.split('.')\n            for (const key of keys) {\n                // console.log(key,keys);  data (4) ['data', 'config', 'style', 'color']\n                if (obj){\n                    obj = obj[key]\n                }\n            }\n            return obj\n        }\n        safeGet(res,'data.config.style.color')\n\ntoLocaleString 数值转货币\n   // toLocaleString(locale,options)  参数：1.语言类型字符串 2.配置对象\n        // 1.数字分割 123,456.789\n        const num1 = 123456.789\n        console.log(num1.toLocaleString()); //123,456.789\n        // 2.数字转为百分比 \n        const num2 = 0.12\n        console.log(num2.toLocaleString('zh',{style: 'percent'})); //12%\n        // 3.数字转货币表示\n        const num3 = 1000000\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny'})); //¥1,000,000.00\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny',currencyDisplay:'code'})); //CNY 1,000,000.00\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny',currencyDisplay:'name'})); //1,000,000.00人民币\n\n当parseInt遇到map\n const data = ['1','2','3']\n        console.log(data.map(parseInt)); //1 nan nan\n        // map里需要一个函数 函数有三个参数 item index self\n        // parseInt(str,[radix进制2-36]) 函数可解析一个字符串，并返回一个整数\n        // 1 0\n        // 2 1 //没有1进制\n        // 3 2 // 2进制里没有3\n        console.log(parseInt(\"0x10\",16));\n\n\t   // parseInt(str,[radix进制2-36]) 函数可解析一个字符串，并返回一个整数\n        // 当忽略参数 radix , JavaScript 默认数字的基数如下:\n        //     如果 string 以 \"0x\" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。\n        //     如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。\n        //     如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。\n\n\n传送数据value是undefined时\n // 传送数据给后端，value是undefined时，被忽略，理想要{}\n        const formInfo = [\n            {\n                fieldId: 1,\n                value: undefined\n            },\n            {\n                fieldId:2,\n                value: 2\n            }\n        ]\n        const result = JSON.stringify(formInfo)\n        console.log(result,typeof(result));\n        // [{\"fieldId\":1},{\"fieldId\":2,\"value\":2}] string\n        // 以下处理\n        // 方法1\n        const newFormInfo = formInfo.map(item => {\n            const value = item.value === undefined ? '' : item.value\n            return {...item,value}\n        })\n        const result2 = JSON.stringify(newFormInfo)\n        console.log(result2); \n        // 方法2 利用JSON.stringfy的第二参数\n        const result3 = JSON.stringify(formInfo, (key,value)=> value === undefined? '' : value)\n        console.log(result3);\n\n算法\n    // 根据roles数组，生成key:id值 value:角色名  对象\n    const initRoleNames = (roles:IRole[])=>{\n        const newRoleNames = roles.reduce((prev:any,role)=>{\n            prev[role._id] = role.name\n            return prev\n        } ,{})\n        // 保存起来\n        setRoleNames(newRoleNames)        \n    }\n")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);