(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{427:function(n,t,e){"use strict";e.r(t);var s=e(2),a=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"ajax-asynchronous-javascript-and-xml-异步的javascript-和-xml"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ajax-asynchronous-javascript-and-xml-异步的javascript-和-xml"}},[n._v("#")]),n._v(" Ajax: Asynchronous Javascript and XML(异步的JavaScript 和 XML)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n实现：\n\t1.在网页不刷新的下，与服务器进行数据交互（向服务端发送http请求，并得到http响应）\n\t2.实现懒加载，用则加载，不用则不加载\n\n在 AJAX 被发明之前，浏览器是怎么发起请求的？\n\n1.地址栏\t输入 http://baidu.com ，按回车，就向服务器发起了一个请求。（同时页面刷新）\n2.a 标签\t用户点击页面中的 a 链接，也会发起一个请求。（同时页面刷新）\n3.img 标签\t页面中如果有 img 标签，那么就会发起一个对此图片的请求（页面没有刷新）（但是只能请求图片）类似的还有 link 标签、script 标签，都可以对一类文件的请求。\n\n为什么我们需要 AJAX？\n上面列举的请求发起方式，要么会导致页面刷新，要么只能请求特定类型的文件（图片、CSS 或 JS）。\n\nC:\\Users\\chenm\\Desktop\\Ajax\\代码\\代码\\3-原生AJAX\n四种发送ajax的方式\n\t1.原生ajax\n\t2.jquery\n\t3.fetch函数\n\t4.axios工具包\n\t\nXML：eXtensible Markup Language \n可扩展标记语言，被设计用来传输和存储数据，没有预定义标签，全是自定义\nHTML是用来呈现数据\nXML被JSON替代了\n\nAJAX\n\t优点：\t不刷新就能发送请求和获取\n\t\t   允许根据用户事件来更新部分内容\n\t缺点：\t没有浏览历史，不能回退\n\t\t   存在跨域问题 //a.com网页 向 b.com发送请求，默认不允许\n\t\t   SEO不友好\n\n\n原生ajax\n\nC:\\Users\\chenm\\Desktop\\Ajax\\代码\\代码\\3-原生AJAX\n使用xhr发送get请求\n1.创建xhr对象\nVar xhr = new XHRHttpreqiest()\n2.调用open（请求方式、url）\nXhr.open(“GET”,URL)\n3.发送ajax请求\nXhr.send()\n4.监听onreadystatechange事件\nXhr.onreadystatechange = function(){\n //监听请求状态readystate 和服务器相应状态status\nIf(xhr.readystate === 4 && xhr.status === 200){\n   //打印数据\nConsole.log(xhr.responseText)\n}\n}\n")])])]),t("h2",{attrs:{id:"axios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios"}},[n._v("#")]),n._v(" Axios")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('是一个ajax工具包，专注于网络数据请求的库，比jQuery轻量，vue和react推荐\n比xhr简单易用\n\naxios.get("url",{params:paramsObj}).then((res)=>{\n\tconst result = res.data\n},(err)=>{\n\n})\n\naxios.post("url",dataObj).then((res)=>{\n\tconst result = res.data\n})\n\naxhios({\n\tmethod:"请求类型",\n\turl:"",\n\tdata:{Post数据},\n\tparams:{get参数}\n}).then(callback Fn)\n\n')])])]),t("h2",{attrs:{id:"封装axios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装axios"}},[n._v("#")]),n._v(" 封装Axios")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import axios from 'axios'\nimport {message} from 'antd'\n// 同一处理失败 在外层包裹一个Promise，且出错时，不reject\nconst ajax = (url:string,data:object={},type:string=\"GET\"): any => {\n    let promise\n    return new Promise((resolve,reject)=>{\n        //1.执行异步请求\n        if(type === \"GET\"){\n            // 发送get请求\n            promise = axios.get(url,{\n                // 配置对象\n                params: data\n            })\n        }else{\n            promise = axios.post(url,data)\n        }\n        //2.如果成功了，调用resolve(value)\n        promise.then((response)=>{\n            resolve(response)\n            //正常 如果失败了,调用reject(reason)，用try catch\n        //3.如果失败了 不调用,而是提示异常信息\n        }).catch((error\n        )=>{\n            //reject(error)\n            message.error('请求出错' + error.message)\n        })\n    })\n    \n}\nexport default ajax\n\n//异步直接得到data\nresolve(response.data)\n")])])]),t("h2",{attrs:{id:"封装2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装2"}},[n._v("#")]),n._v(" 封装2")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("##这个封装没有改变axios使用方法\n##如何像上面那个封装一样呢\nsrc中新建request文件夹\nrequest.ts\napi.ts\n\n在request.ts中\nimport axios from 'axios'\nimport storageUtils from 'utils/storageUtils';\n// 配置项接口\ninterface AxiosOption {\n    baseURL: string;\n    timeout: number;\n}\n// 配置项\nconst axiosOption: AxiosOption = {\n    baseURL: '/api1', //根据跨域配置\n    timeout: 5000\n}\n// 创建一个单例\nconst instance = axios.create(axiosOption);\n// 添加请求拦截器\ninstance.interceptors.request.use(function (config) {\n  // let token = localStorage.getItem(\"cms-token\"); //这个要改成服务器返回的字段 默认token\n  let token = storageUtils.getUser()['cms-token']\n  if (token) {\n    config.headers = {\n      \"cms-token\": token\n    }\n  }\n  return config;\n}, function (error) {\n  // 对请求错误做些什么\n  return Promise.reject(error);\n});\n// 添加响应拦截器\ninstance.interceptors.response.use(function (response) {\n  // 对响应数据做点什么\n  return response.data;\n}, function (error) {\n  // 对响应错误做点什么\n  return Promise.reject(error);\n});\nexport default instance;\n\n\napi.ts\nimport request from './request'\ninterface IRegisterParams {\n    username: string;\n    password: string;\n}\n// 获取用户信息\nexport const UserInfoApi = ()=> request.get('/info')\n\n// 获取文章列表分页\nexport const GetArticleListApi = (params:{current:number,counts:number})=> request.post('/article/list',params)\n\n// 修改用户信息\ninterface IChangeUser {\n    username?: string;\n    password?: string;\n}\nexport const ChangeUserApi = (params:IRegisterParams)=> request.post('/info',params)\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);