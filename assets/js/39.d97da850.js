(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{444:function(n,t,e){"use strict";e.r(t);var a=e(2),r=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"前端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端"}},[n._v("#")]),n._v(" 前端")]),n._v(" "),t("h2",{attrs:{id:"best-practice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#best-practice"}},[n._v("#")]),n._v(" best practice")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1. 不用var 优先const 再let\n\n什么是可维护的代码\n通常，说代码“可维护”就意味着它具备如下特点。\n 容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。\n 符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。\n 容易适配：即使数据发生变化也不用完全重写。\n 容易扩展：代码架构经过认真设计，支持未来扩展核心功能。\n 容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。\n\n编码规范\n")])])]),t("h2",{attrs:{id:"数据处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据处理"}},[n._v("#")]),n._v(" 数据处理")]),n._v(" "),t("h3",{attrs:{id:"对数据进行分组和计数处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对数据进行分组和计数处理"}},[n._v("#")]),n._v(" 对数据进行分组和计数处理")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('let data = [\n\t{id:"1",group_id:"111"},\n\t{id:"2",group_id:"111"},\n\t{id:"3",group_id:"111"},\n\t{id:"4",group_id:"222"},\n\t{id:"5",group_id:"222"}\n\t]\n---\x3e\n [\n\t{id:"1",group_id:"111",rowSpan:3},\n \t{id:"2",group_id:"111"},\n \t{id:"3",group_id:"111"},\n \t{id:"4",group_id:"222",rowSpan:2},\n\t{id:"5",group_id:"222"}\n ]\n为什么需要rowSpan，是因为要用于表格合并\n！使用reducer进行分组和计数\n\nlet tempData = data\ntempData = tempData.reduce((arr,item)=>{\n\tlet find = arr.find(i => i.group_id === item.group_id)\n\tlet tempObj = {...item, rowSpan:1}\n\tif(find){\n\t\tfind.rowSpan++\n\t\tarr.push(item)\n\t}else{\n\t\tarr.push(tempObj)\n\t}\n\treturn arr\n},[])\n')])])]),t("h3",{attrs:{id:"路由跳转常见的传参方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由跳转常见的传参方式"}},[n._v("#")]),n._v(" 路由跳转常见的传参方式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("点击表单的某一行，将改行id传给修改页面\n1. params传参 体现在url  /id\n注意路由地址:id\n\n注意测试时刷新页面\n\n2. query\n注意路由不要加:id\n拼接在url后  ?id=23\n")])])]),t("h3",{attrs:{id:"字符之间多个空格的处理方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符之间多个空格的处理方案"}},[n._v("#")]),n._v(" 字符之间多个空格的处理方案")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const str = '公司部门：'+'领导小组'+'\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0'+'领导：'+'XXX'\n\n用\\xa0 代替&nbsp\n用空格代替的话，不行，因为浏览器会把多个空格缩减到1个\n")])])]),t("h3",{attrs:{id:"图标制作库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图标制作库"}},[n._v("#")]),n._v(" 图标制作库")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("echart\n但是分页图echart不行\n\n用bizCharts\n")])])]),t("h3",{attrs:{id:"项目部署开启gzip压缩加载资源-大大提升页面性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目部署开启gzip压缩加载资源-大大提升页面性能"}},[n._v("#")]),n._v(" 项目部署开启gzip压缩加载资源，大大提升页面性能")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("看response里是否开启gzip资源压缩\n\n只需要在nginx上配置就可以了\ntomcat也可以配置\n")])])]),t("h3",{attrs:{id:"如何在前端的url后面加param"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何在前端的url后面加param"}},[n._v("#")]),n._v(" 如何在前端的url后面加param")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("axios发送请求时不要写data 写params\n\n")])])]),t("h3",{attrs:{id:"数组扁平化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组扁平化"}},[n._v("#")]),n._v(" 数组扁平化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("就是讲一个多维数组变成一个一维数组\n[1,2,[3,4,5]]\n---\x3e\n[1,2,3,4,5]\n\n1. ES6的flat方法 最简单\nlet arr = [1,2,[3,4,[5,6]]]\narr.flat(Infinity)\n\n2. JSON \nlet res = JSON.stringfy(arr.replace(/\\[|\\]/g,''))\nres = JSON.parse('['+res+']')\n\n3. reduce方法\nfunction flatten(arr){\n\treturn arr.reduce((result,item)=>{\n\t\treturn result.concat(Array.isArray(item)? flatten(item):item)\n\t},[])\n}\n")])])]),t("h2",{attrs:{id:"前端debug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端debug"}},[n._v("#")]),n._v(" 前端debug")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('①locatorJS 谷歌插件\nalt + 左键页面 会直接跳转到 IDE上代码位置\n\n也可以不通过谷歌插件，直接npm 下载配置\n注意不支持React版本15之后\n\n②vscode\n小爬虫里配置debug\n一个作为主要使用浏览器 另外一个作为debug浏览器\nedge和chrome 内核一样\n\n{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "msedge", //edge\n            "request": "launch",\n            "name": "Launch Edge against localhost",\n            "url": "http://localhost:8080", //自己的项目端口\n            "webRoot": "${workspaceFolder}"\n        }\n    ]\n}\n\n\n③vscode 右键行数 logpoint\nname:{name}   \n')])])]),t("h2",{attrs:{id:"兼容性网站"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#兼容性网站"}},[n._v("#")]),n._v(" 兼容性网站")]),n._v(" "),t("p",[n._v("caniuse.com")]),n._v(" "),t("h2",{attrs:{id:"iconfont字体图标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iconfont字体图标"}},[n._v("#")]),n._v(" iconfont字体图标")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('https://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.4&sortType=favorite\n1. 首先打开官方网址 IconFont-阿里巴巴矢量图标库\n2. 登录相关账号\n3. 添加需要的图标入库 在IconFont找到需要的图标点击添加入库\n4. 添加到项目 添加入库后，点击右上角的购物车按钮 点击添加到项目\n5. 新建项目\n6. 下载到本地\n\n第一步：引入项目下面生成的 fontclass 代码：\n<link rel="stylesheet" href="./iconfont.css">\n<link rel="stylesheet" href="./iconfont.css">\n第二步：挑选相应图标并获取类名，应用于页面：\n<span class="iconfont icon-xxx"></span>\n<span class="iconfont icon-xxx"></span>\n\n在原来的iconfont图标中添加新的图标\n将新的iconfont.css中的 除 .iconfont{......} 外 的所有代码拷贝到原来的iconfont.css中代码的后面即可。\n\n，iconfont.cn 是一个 UGC 的内容平台。对于其内容的原创性、著作权等，iconfont.cn 没有办法做到很好的审核，所以随意使用是会有版权风险的。\n这里推荐一个图标库：remixicon.com ，图标数量确实没有 iconfont 那么多，但是优势是所以图标均由作者一枚枚绘制，风格统一，并开源免费商用。用得爽的话可以给作者（其实就是我）的 github 项目一个 star 支持一下，当然也不强求，如果能推荐给身边的朋友同事那就更棒了。\n\n如果图标库没有项目所需的图标\n1.与设计师沟通，得到矢量图SVG\n2.iconFont网站上传图标，下载使用\n')])])]),t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[n._v("#")]),n._v(" webpack")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1.webpack默认处理js/json，不能处理css，img等其他\n2.能将ES6模块化编译成浏览器能识别的模块化\n3.生产模式比开发模式多了个压缩\n\n5个核心\n1.入口文件entry\n -index.js \n\t以此文件为入口开始打包\n2.输出outPut\n -bundles包\n\t输出到哪里，以及命名\n3.Loader \n- webpack 默认只能初始js JSON文件，\n-loader使得webpack处理其他资源：图片 css等 翻译官\n\n4.Plugins\n- 打包优化和压缩，…到重定义环境中的变量\n\n5.Mode\n - development 配置相对简单，能运行\n - production 优化配置等\n\n1.初始化包描述文件\nnpm init\npackage name: webpack_test 命名\n2.下包\nnpm i webpack webpack-cli -g //先全局\nnpm i  webpack webpack-cli -D //本地安装，添加到package.json中的开发依赖\nwebpack中下载所有东西都属于开发依赖\n出现三个文件\nnode_modules\npackage-lock.json\npackage.son\nwebpack.config.js //webpack配置文件 配置css等\n//新建\nsrc //项目代码目录\n\tindex.js //入口文件\nbuild //打包目录\n\n//运行指令\n开发环境：\n\twebpack --entry ./src/index.js --output-path ./build/built.js --mode=development\n\t以index.js为入口开始打包，输出到build/built.js 开发环境\n\t会有一个hash值，可以作为文件命名\n生产环境：\n\twebpack --entry ./src/index.js --output-path ./build/built.js --mode=production\n\t多了个压缩环节\n\n\n")])])]),t("h2",{attrs:{id:"webpack-config-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-config-js"}},[n._v("#")]),n._v(" webpack.config.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("构建工具基于node，模块化采用commonjs\n配置css\nnpm i css-loader style-loader -D\n配置less\nnpm i less-loader less -D \n\n打包html\n\t1. 下载 2.引用 3.使用\nnpm i html-webpack-plugin -D\n\n//处理图片资源\nnpm i url-loader -D\nnpm i file-loader -D\nnpm i html-loader -D\n\n//处理其他资源 - 字体图标等 -file-loader\n\n//npm i  webpack-dev-server -D\n//本地下载的话，启动需要 npx webpack-dev-server\n\n//引入，它是一个类，通过new调用\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n//resolve用来拼接绝对路径\nconst {resolve} = require('path')\n//暴露模块\nmodules.exports = {\n\t//入口\n\tentry : './src/index.js',\n\t//输出\n\toutput : {\n\t\t//输出文件名\n\t\tfilename: 'built.js'\n\t\t//输出路径 选择绝对路径\n\t\t// __dirname变量表当前文件(config)的目录的绝对路径,拼接上'build'\n\t\tpath : resolve(__dirname, 'build')\n\t},\n\t//loader配置\n\tmodule: {\n\t\trules: [\n\t\t\t//打包其他资源\n\t\t\t{\n\t\t\t\t//排除\n\t\t\t\texclude: / \\.(css|js|html)$/\n\t\t\t\tloader: 'file-loader'\n\t\t\t}\n\t\t\t//详细loader配置 每个对象对应一个配置\n\t\t\t{\n\t\t\t\t//匹配哪些文件 写正则，匹配以.css结尾的文件\n\t\t\t\ttest : / \\.css$/，\n\t\t\t\t//使用哪些loader处理\n\t\t\t\tuse: [\n\t\t\t\t//执行顺序从下往上\n\t\t\t\t\t//2. 创建style标签，将js中的样式资源插入进行，添加到head中生效\n\t\t\t\t\t'style-loader',\n\t\t\t\t\t//1. 将css以字符串形式，变成commonjs模块，加载到js中\n\t\t\t\t\t'css-loader'\n\t\t\t\t]\n\t\t\t}\n\t\t\t//配置less\n\t\t\t{\n\t\t\t\ttest : / \\.less$/，\n\t\t\t\tuse: [\n\t\t\t\t\t'style-loader',\n\t\t\t\t\t'css-loader',\n\t\t\t\t\t'less-loader'\n\t\t\t\t]\n\t\t\t\n\t\t\t}\n\t\t\t//处理图片资源 问题：默认处理不了img标签图片\n\t\t\t{\n\t\t\t\ttest : / \\.jpg|png|gif$/，\n\t\t\t\tuse: [\n\t\t\t\t\t'url-loader']\n\t\t\t\toptions: {\n\t\t\t\t//如果图片大小小于8kb，就会被base64处理，将图片转为base64字符串，浏览器会将base64字符串当做图片解析\n\t\t\t\t//base64优点：减少请求数量， 缺点：图片体积会更大\n\t\t\t\t\tlimit: 8 * 1024  //即8kb\n\t\t\t\t//url-loader使用es6模块解析，html-loader是commonjs\n\t\t\t\t//解析时问题 [object Module]\n\t\t\t\t//解决: 关闭es6模块化\n\t\t\t\t         esModule: false\n\t\t\t\t//重命名：取hash值前10位，ext是文件原扩展名\n\t\t\t\t         name: '[hash:10].[ext]'\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest : / \\.html$/，\n\t\t\t\t//处理img标签图片\n\t\t\t\tuse: [\n\t\t\t\t\t'html-loader']\n\t\t\t\toptions: {\n\t\t\t\t\t//esModule: false  //可能这边需要\n\t\t\t\t\t，\n\t\t\t\t\toutput：“目录名”\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t]\n\t},\n\t//plugins的配置\n\tplugins: [\n\t\t//不传参，打包后，创建一个空的HTML文件，默认引入built.js等所有打包输出的资源\n\t\tnew HtmlWebpackPlugin(\n\t\t\t//以src中的html为样本，复制\n\t\t\ttemplate: './src/index.html'\n\t\t)\n\t],\n\t// mode 模式二选一\n\tmode: 'development'\n\t// mode: 'production'\n\t\n\t//devServer 自动打包，打开浏览器，刷新\n\t//只会在内存中打包，不会输出\n\t//启动指令: webpack-dev-server\n\tdevServer: {\n\t\tcontentBase: resolve(__dirname, 'build'),\n\t\t//启动gzip压缩\n\t\tcompress: 'true',\n\t\t//端口号\n\t\tport: 3000,\n\t\t//打开浏览器\n\t\topen: true\n\t}\n}\n")])])]),t("h2",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[n._v("#")]),n._v(" es6")]),n._v(" "),t("h3",{attrs:{id:"扩展运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[n._v("#")]),n._v(" 扩展运算符")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('1.数组合并\n2.数组克隆\n3.将伪数组转为真正的数组\n\nex1. 数组合并\nconst country = ["China","Japan"]\nconst language = ["Chinese","Japanese"]\n//const country_and_language = country.concat(language)\nconst country_and_language = [...country,...language]\n\nex2. 数组克隆\nconst country = ["China","Japan"]\nconst country2 = [...country]\n\nex3. 转化为真正的数组\nconst divs = document.querySelectorAll("div")\nconst divArr = [...divs]\n')])])]),t("h3",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[n._v("#")]),n._v(" Symbol")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('1. 给对象添加属性和方法  没理解\nex. 给对象添加up和down方法，但不确定原本有没有up和down方法\n\nlet game = {\n\tgame.up=function(){}\n}\n\nlet methods = {\n\tup:Symbol(),\n\tdown:Symbol()\n}\n\ngame[methods.up]= function(){}\ngame[methods.down]= function(){}\n\nlet youxi ={\n\tname:"狼人杀",\n\t[Symbol("speak")]:function(){},\n\t[Symbol("kill")]:function(){},\n\n}\n\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("## 二、github搜索案例相关知识点\n        1.设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。\n        2.ES6小知识点：解构赋值+重命名\n                    let obj = {a:{b:1}}\n                    const {a} = obj; //传统解构赋值\n                    const {a:{b}} = obj; //连续解构赋值\n                    const {a:{b:value}} = obj; //连续解构赋值+重命名\n        3.消息订阅与发布机制\n                    1.先订阅，再发布（理解：有一种隔空对话的感觉）\n                    2.适用于任意组件间通信\n                    3.要在组件的componentWillUnmount中取消订阅\n        4.fetch发送请求（关注分离的设计思想）\n                    try {\n                        const response= await fetch(`/api1/search/users2?q=${keyWord}`)\n                        const data = await response.json()\n                        console.log(data);\n                    } catch (error) {\n                        console.log('请求出错',error);\n                    }\n\n\ndelete obj.a\n\narr.map()\n对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组\n//返回nums中每一项乘以2的数组\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.map(    (  item, index, arr)=> item * 2  ) // [2, 4, 6, 8, 10, 8, 6, 4, 2]\n\n//用于删除数组中某一项\narr.filter()\n对数组中的每一项运行给定函数，返回该函数会返回true的项组成的新数组\n//返回nums中所有值大于2的数组\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.filter((item, index, arr)=> item >2 ) //[3, 4, 5, 4, 3]\n\n//用于条件统计 条件求和… \narr.reduce()\n从左开始\n//求数组所有元素之和\nvar nums = [1,2,3,4,5]\nnums.reduce((prev,cur,index,arr)=>prev+cur) //15\narr.reduceRight()\n从右开始\n//求数组所有元素之和\nvar nums = [1,2,3,4,5]\nnums.reduceRight((prev,cur,index,arr)=>prev+cur) //15\n\nreduce((pre,cur)=>{return pre + (cur.done ? 1 : 0)},0)\npre是上一次的返回值，第一次没有，以传入的0为主\ncur是数组每一项\n\n\n\n\n# day01\n## 1. 项目开发准备\n    1). 描述项目\n    2). 技术选型 \n    3). API接口/接口文档/测试接口\n    \n## 2. 启动项目开发\n    1). 使用react脚手架创建项目\n    2). 开发环境运行: npm start\n    3). 生产环境打包运行: npm run build   serve build\n## 3. git管理项目\n        \n## 4. 创建项目的基本结构\n    api: ajax请求的模块\n    components: 非路由组件\n    pages: 路由组件\n    App.js: 应用的根组件\n    index.js: 入口js\n    \n## 5 引入antd\n    下载antd的包\n    按需打包: 只打包import引入组件的js/css\n        下载工具包\n        config-overrides.js\n        package.json\n    自定义主题\n        下载工具包\n        config-overrides.js\n    使用antd的组件\n        根据antd的文档编写\n        \n## 6. 引入路由\n    下载包: react-router-dom\n    拆分应用路由:\n      Login: 登陆\n      Admin: 后台管理界面\n    注册路由:\n      <BrowserRouter>\n      <Switch>\n      <Route path='' component={}/>\n      \n## 7. Login的静态组件\n    1). 自定义了一部分样式布局\n    2). 使用antd的组件实现登陆表单界面\n      Form  / Form.Item\n      Input\n      Icon\n      Button\n## 8. 收集表单数据和表单的前台验证\n    1). form对象\n        如何让包含<Form>的组件得到form对象?  WrapLoginForm = Form.create()(LoginForm)\n        WrapLoginForm是LoginForm的父组件, 它给LoginForm传入form属性\n        用到了高阶函数和高阶组件的技术\n    2). 操作表单数据\n        form.getFieldDecorator('标识名称', {initialValue: 初始值, rules: []})(<Input/>)包装表单项组件标签\n        form.getFieldsValue(): 得到包含所有输入数据的对象\n        form.getFieldValue(id): 根据标识得到对应字段输入的数据\n    \n    3). 前台表单验证\n        a. 声明式实时表单验证:\n            form.getFieldDecorator('标识名称', {rules: [{min: 4, message: '错误提示信息'}]})(<Input/>)\n        b. 自定义表单验证\n            form.getFieldDecorator('标识名称', {rules: [{validator: this.validatePwd}]})(<Input/>)\n            validatePwd = (rule, value, callback) => {\n              if(有问题) callback('错误提示信息') else callack()\n            } \n        c. 点击提示时统一验证\n            form.validateFields((error, values) => {\n              if(!error) {通过了验证, 发送ajax请求}\n            })\n            \n## 9. 高阶函数与高阶组件\n    1. 高阶函数\n        1). 一类特别的函数\n            a. 接受函数类型的参数\n            b. 返回值是函数\n        2). 常见\n            a. 定时器: setTimeout()/setInterval()\n            b. Promise: Promise(() => {}) then(value => {}, reason => {})\n            c. 数组遍历相关的方法: forEach()/filter()/map()/reduce()/find()/findIndex()\n            d. 函数对象的bind()\n            e. Form.create()() / getFieldDecorator()()\n        3). 高阶函数更新动态, 更加具有扩展性\n    \n    2. 高阶组件\n        1). 本质就是一个函数\n        2). 接收一个组件(被包装组件), 返回一个新的组件(包装组件), 包装组件会向被包装组件传入特定属性\n        3). 作用: 扩展组件的功能\n        \n    3. 高阶组件与高阶函数的关系\n        高阶组件是特别的高阶函数\n        接收一个组件函数, 返回是一个新的组件函数\n        \n# day02\n## 1. 后台应用\n    启动后台应用: mongodb服务必须启动\n    使用postman测试接口(根据接口文档):\n        访问测试: post请求的参数在body中设置\n        保存测试接口\n        导出/导入所有测试接口\n        \n## 2. 编写ajax代码\n    1). ajax请求函数模块: api/ajax.js\n        封装axios + Promise\n        函数的返回值是promise对象  ===> 后面用上async/await\n        自己创建Promise\n          1. 内部统一处理请求异常: 外部的调用都不用使用try..catch来处理请求异常\n          2. 异步返回是响应数据(而不是响应对象): 外部的调用异步得到的就直接是数据了(response --\x3e response.data)\n    2). 接口请求函数模块: api/index.js\n        根据接口文档编写(一定要具备这个能力)\n        接口请求函数: 使用ajax(), 返回值promise对象\n    3). 解决ajax跨域请求问题(开发时)\n        办法: 配置代理  ==> 只能解决开发环境\n        编码: package.json: proxy: \"http://localhost:5000\"\n    4). 对代理的理解\n        1). 是什么?\n            具有特定功能的程序\n        2). 运行在哪?\n            前台应用端\n            只能在开发时使用\n        3). 作用?\n            解决开发时的ajax请求跨域问题\n            a. 监视并拦截请求(3000)\n            b. 转发请求(4000)\n        4). 配置代理\n            告诉代理服务器一些信息: 比如转发的目标地址\n            开发环境: 前端工程师\n            生产环境: 后端工程师\n    5). async和await\n        a. 作用?\n           简化promise对象的使用: 不用再使用then()来指定成功/失败的回调函数\n           以同步编码(没有回调函数了)方式实现异步流程\n        b. 哪里写await?\n            在返回promise的表达式左侧写await: 不想要promise, 想要promise异步执行的成功的value数据\n        c. 哪里写async?\n            await所在函数(最近的)定义的左侧写async\n            \n## 3. 实现登陆(包含自动登陆)\n    login.jsx\n        1). 调用登陆的接口请求\n        2). 如果失败, 显示错误提示信息\n        3). 如果成功了:\n            保存user到local/内存中\n            跳转到admin\n        4). 如果内存中的user有值, 自动跳转到admin\n    src/index.js\n        读取local中user到内存中保存\n    admin.jsx\n        判断如果内存中没有user(_id没有值), 自动跳转到login\n    storageUtils.js\n        包含使用localStorage来保存user相关操作的工具模块\n        使用第三库store\n            简化编码\n            兼容不同的浏览器\n    memoryUtils.js\n        用来在内存中保存数据(user)的工具类\n        \n## 4. 搭建admin的整体界面结构\n    1). 整体布局使用antd的Layout组件\n    2). 拆分组件\n        LeftNav: 左侧导航\n        Header: 右侧头部\n    3). 子路由\n        定义路由组件\n        注册路由\n        \n## 5. LeftNav组件\n    1). 使用antd的组件\n        Menu / Item / SubMenu\n    \n    2). 使用react-router\n        withRouter(): 包装非路由组件, 给其传入history/location/match属性\n        history: push()/replace()/goBack()\n        location: pathname属性\n        match: params属性\n    \n    3). componentWillMount与componentDidMount的比较\n        componentWillMount: 在第一次render()前调用一次, 为第一次render()准备数据(同步)\n        componentDidMount: 在第一次render()之后调用一次, 启动异步任务, 后面异步更新状态重新render\n    \n    4). 根据动态生成Item和SubMenu的数组\n        map() + 递归: 多级菜单列表\n        reduce() + 递归: 多级菜单列表\n    \n    5). 2个问题?\n        刷新时如何选中对应的菜单项?\n            selectedKey是当前请求的path\n        刷新子菜单路径时, 自动打开子菜单列表?\n            openKey是 一级列表项的某个子菜单项是当前对应的菜单项\n            \n# day03\n## 1. Header组件\n    1). 界面静态布局\n        三角形效果\n    2). 获取登陆用户的名称显示\n        MemoryUtils\n    3). 当前时间\n        循环定时器, 每隔1s更新当前时间状态\n        格式化指定时间: dateUtils\n    4). 天气预报\n        使用jsonp库发jsonp请求百度天气预报接口\n        对jsonp请求的理解\n    5). 当前导航项的标题\n        得到当前请求的路由path: withRouter()包装非路由组件\n        根据path在menuList中遍历查找对应的item的title\n    6). 退出登陆\n        Modal组件显示提示\n        清除保存的user\n        跳转到login\n    7). 抽取通用的类链接按钮组件\n        通过...透传所有接收的属性: <Button {...props} />    <LinkButton>xxxx</LinkButton>\n        组件标签的所有子节点都会成为组件的children属性\n        \n## 2. jsonp解决ajax跨域的原理\n    1). jsonp只能解决GET类型的ajax请求跨域问题\n    2). jsonp请求不是ajax请求, 而是一般的get请求\n    3). 基本原理\n        浏览器端:\n            动态生成<script>来请求后台接口(src就是接口的url)\n            定义好用于接收响应数据的函数(fn), 并将函数名通过请求参数提交给后台(如: callback=fn)\n        服务器端:\n            接收到请求处理产生结果数据后, 返回一个函数调用的js代码, 并将结果数据作为实参传入函数调用\n        浏览器端:\n            收到响应自动执行函数调用的js代码, 也就执行了提前定义好的回调函数, 并得到了需要的结果数据\n           \n# day04: Category组件\n## 1. 使用antd组件构建分类列表界面\n    Card\n    Table\n    Button\n    Icon\n        \n## 2. 相关接口请求函数\n    获取一级/二级分类列表\n    添加分类\n    更新分类\n        \n## 3. 异步显示一级分类列表    \n    设计一级分类列表的状态: categorys\n    异步获取一级分类列表: componentDidMount(){}\n    更新状态, 显示\n## 4. 显示二级分类列表\n    设计状态: subCategorys / parentId / parentName\n    显示二级分类列表: 根据parentId状态值, 异步获取分类列表\n    setState()的问题\n        setState()更新状态是异步更新的, 直接读取状态值还是旧的状态值\n        setState({}, [callback]), 回调函数是在状态更新且界面更新之后执行, 可以在此获取最新的状态\n        \n## 5. 更新分类\n    1). 界面\n        antd组件: Modal, Form, Input\n        显示/隐藏: showStatus状态为2/0\n        \n    2). 功能\n        父组(Category)件得到子组件(AddForm)的数据(form)\n        调用更新分类的接口\n        重新获取分类列表\n        \n        \n# day05\n## 1. 添加分类\n    1). 界面\n        antd组件: Modal, Form, Select, Input\n        显示/隐藏: showStatus状态为1/0\n        \n    2). 功能\n        父组(Category)件得到子组件(AddForm)的数据(form)\n        调用添加分类的接口\n        重新获取分类列表\n## 2. Product整体路由\n    1). 配置子路由: \n        ProductHome / ProductDetail / ProductAddUpdate\n        <Route> / <Switch> / <Redirect>\n    \n    2). 匹配路由的逻辑:\n        默认: 逐层匹配   <Route path='/product' component={ProductHome}/>\n        exact属性: 完全匹配\n        \n## 3. 分页实现技术(2种)\n    1). 前台分页/简单分页\n        请求获取数据: 一次获取所有数据, 翻页时不需要再发请求\n        请求接口: \n            不需要指定请求参数: 页码(pageNum)和每页数量(pageSize)\n            响应数据: 所有数据的数组\n    \n    2). 基于后台的分页\n        请求获取数据: 每次只获取当前页的数据, 翻页时要发请求\n        请求接口: \n            需要指定请求参数: 页码(pageNum)和每页数量(pageSize)\n            响应数据: 当前页数据的数组 + 总记录数(total)\n    \n    3). 如何选择?\n        基本根据数据多少来选择\n        \n## 4. ProductHome组件\n    1). 分页显示\n       界面: <Card> / <Table> / Select / Icon / Input / Button\n       状态: products / total\n       接口请求函数需要的数据: pageNum, pageSize\n       异步获取第一页数据显示\n           调用分页的接口请求函数, 获取到当前页的products和总记录数total\n           更新状态: products / total\n       翻页:\n           绑定翻页的监听, 监听回调需要得到pageNum\n           异步获取指定页码的数据显示  \n     \n    2). 搜索分页\n       接口请求函数需要的数据: \n           pageSize: 每页的条目数\n           pageNum: 当前请求第几页 (从1开始)\n           productDesc / productName: searchName 根据商品描述/名称搜索\n       状态:  searchType / searchName  / 在用户操作时实时收集数据\n       异步搜索显示分页列表\n           如果searchName有值, 调用搜索的接口请求函数获取数据并更新状态\n           \n    3). 更新商品的状态\n       初始显示: 根据product的status属性来显示  status = 1/2\n       点击切换:\n           绑定点击监听\n           异步请求更新状态\n    \n    4). 进入详情界面\n       history.push('/product/detail', {product})\n    \n    5). 进入添加界面\n        history.push('/product/addupdate')\n        \n## 5. ProductDetail组件\n    1). 读取商品数据: this.props.location.state.product\n    2). 显示商品信息: <Card> / List \n    3). 异步显示商品所属分类的名称\n        pCategoryId==0 : 异步获取categoryId的分类名称\n        pCategoryId!=0: 异步获取 pCategoryId/categoryId的分类名称\n    4). Promise.all([promise1, promise2])\n        返回值是promise\n        异步得到的是所有promsie的结果的数组\n        特点: 一次发多个请求, 只有当所有请求都成功, 才成功, 并得到成功的数据,一旦有一个失败, 整个都失败\n# day06\n## 1. ProductAddUpdate\n    1). 基本界面\n        Card / Form / Input / TextArea / Button\n        FormItem的label标题和layout\n        \n    2). 分类的级联列表\n        Cascader的基本使用\n        异步获取一级分类列表, 生成一级分类options\n        如果当前是更新二级分类的商品, 异步获取对应的二级分类列表, 生成二级分类options, 并添加为对应option的children\n        async函数返回值是一个新promise对象, promise的结果和值由async函数的结果决定\n        当选择某个一级分类项时, 异步获取对应的二级分类列表, 生成二级分类options, 并添加为当前option的children\n    \n    3). 表单数据收集与表单验证\n    \n## 2. PicturesWall\n    1). antd组件\n        Upload / Modal / Icon\n        根据示例DEMO改造编写\n    2). 上传图片\n        在<Upload>上配置接口的path和请求参数名\n        监视文件状态的改变: 上传中 / 上传完成/ 删除\n        在上传成功时, 保存好相关信息: name / url\n        为父组件提供获取已上传图片文件名数组的方法\n    3). 删除图片\n        当文件状态变为删除时, 调用删除图片的接口删除上传到后台的图片\n    4). 父组件调用子组件对象的方法: 使用ref技术\n        1. 创建ref容器: thi.pw = React.createRef()\n        2. 将ref容器交给需要获取的标签元素: <PicturesWall ref={this.pw} />  // 自动将将标签对象添加为pw对象的current属性\n        3. 通过ref容器读取标签元素: this.pw.current\n# day07\n## 1. RichTextEditor\n    1). 使用基于react的富文本编程器插件库: react-draft-wysiwyg\n    2). 参考库的DEMO和API文档编写\n    3). 如果还有不确定的, 百度搜索, 指定相对准确的关键字\n    \n## 2. 完成商品添加与修改功能\n    1). 收集输入数据\n        通过form收集: name/desc/price/pCategoryId/categoryId\n        通过ref收集: imgs/detail\n        如果是更新收集: _id\n        将收集数据封装成product对象\n    2). 更新商品\n        定义添加和更新的接口请求函数\n        调用接口请求函数, 如果成功并返回商品列表界面\n## 3. 角色管理\n    1). 角色前台分页显示\n    2). 添加角色\n    3). 给指定角色授权\n        界面: Tree\n        状态: checkedKeys, 根据传入的role的menus进行初始化\n        勾选某个Node时, 更新checkedKeys\n        点击OK时: 通过ref读取到子组件中的checkedKeys作为要更新product新的menus\n                发请求更新product\n        解决默认勾选不正常的bug: 利用组件的componentWillReceiveProps()\n# day08\n## 1. setState()的使用\n    1). setState(updater, [callback]),\n        updater为返回stateChange对象的函数: (state, props) => stateChange\n        接收的state和props被保证为最新的\n    2). setState(stateChange, [callback])\n        stateChange为对象,\n        callback是可选的回调函数, 在状态更新且界面更新后才执行\n    3). 总结:\n        对象方式是函数方式的简写方式\n            如果新状态不依赖于原状态 ===> 使用对象方式\n            如果新状态依赖于原状态 ===> 使用函数方式\n        如果需要在setState()后获取最新的状态数据, 在第二个callback函数中读取\n## 2. setState()的异步与同步\n    1). setState()更新状态是异步还是同步的?\n        a. 执行setState()的位置?\n            在react控制的回调函数中: 生命周期勾子 / react事件监听回调\n            非react控制的异步回调函数中: 定时器回调 / 原生事件监听回调 / promise回调 /...\n        b. 异步 OR 同步?\n            react相关回调中: 异步\n            其它异步回调中: 同步\n    \n    2). 关于异步的setState()\n        a. 多次调用, 如何处理?\n            setState({}): 合并更新一次状态, 只调用一次render()更新界面 ---状态更新和界面更新都合并了\n            setState(fn): 更新多次状态, 但只调用一次render()更新界面  ---状态更新没有合并, 但界面更新合并了\n        b. 如何得到异步更新后的状态数据?\n            在setState()的callback回调函数中\n## 3. Component与PureComponent\n    1). Component存在的问题?\n        a. 父组件重新render(), 当前组件也会重新执行render(), 即使没有任何变化\n        b. 当前组件setState(), 重新执行render(), 即使state没有任何变化\n  \n    2). 解决Component存在的问题\n        a. 原因: 组件的shouldcomponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行\n        b. 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false\n        c. 办法2: 使用PureComponent代替Component\n        d. 说明: 一般都使用PureComponent来优化组件性能\n  \n    3). PureComponent的基本原理\n        a. 重写实现shouldComponentUpdate()\n        b. 对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true\n        c. 一旦componentShouldUpdate()返回false不再执行用于更新的render()\n  \n    4). 面试题:\n        组件的哪个生命周期勾子能实现组件优化?\n        PureComponent的原理?\n        区别Component与PureComponent?\n## 4. 用户管理\n    1). 显示用户分页列表\n    2). 添加用户\n    3). 修改用户\n    4). 删除用户\n    \n## 5. 导航菜单权限控制\n    1). 基本思路(依赖于后台): \n        角色: 包含所拥有权限的所有菜单项key的数组: menus=[key1, key2, key3]\n        用户: 包含所属角色的ID: role_id\n        当前登陆用户: user中已经包含了所属role对象\n        遍历显示菜单项时: 判断只有当有对应的权限才显示\n    2). 判断是否有权限的条件?\n        a. 如果当前用户是admin\n        b. 如果当前item是公开的\n        c. 当前用户有此item的权限: key有没有menus中\n        d. 如果当前用户有此item的某个子item的权限\n# day09\n## 1. redux理解\n    什么?: redux是专门做状态管理的独立第3方库, 不是react插件, 但一般都用在react项目中\n    作用?: 对应用中状态进行集中式的管理(写/读)\n    开发: 与react-redux, redux-thunk等插件配合使用\n## 2. redux相关API\n    redux中包含: createStore(), applyMiddleware(), combineReducers()\n    store对象: getState(), dispatch(), subscribe()\n    react-redux: \n        <Provider store={store}>: 向所有的容器组件提供store\n        connect(\n            state => ({xxx: state.xxx}),\n            {actionCreator1, actionCreator2}\n        )(UI组件): \n            产生的就是容器组件, 负责向UI组件传递标签属性, \n            一般属性值从state中获取, 函数属性内部会执行dispatch分发action\n## 3. redux核心概念(3个)\n    action: \n        默认是对象(同步action), {type: 'xxx', data: value}, 需要通过对应的actionCreator产生, \n        它的值也可以是函数(异步action), 需要引入redux-thunk才可以\n    reducer\n        根据老的state和指定的action, 返回一个新的state\n        不能修改老的state\n    store\n        redux最核心的管理对象\n        内部管理着: state和reducer\n        提供方法: getState(), dispatch(action), subscribe(listener)\n## 4. redux工作流程\n![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)\n        \n## 5. 使用redux及相关库编码\n    需要引入的库: \n        redux\n        react-redux\n        redux-thunk\n        redux-devtools-extension(这个只在开发时需要)\n    redux文件夹: \n        action-types.js\n        actions.js\n        reducers.js\n        store.js\n    组件分2类: \n        ui组件(components): 不使用redux相关API\n        容器组件(containers): 通过connect()()生成的组件\n        \n# day10\n## 1. 在项目中搭建redux整套环境\n    1). store.js\n    2). reducer.js\n    3). actions.js\n    4). action-types.js\n    5). index.js\n    6). 在需要与redux进行状态数据通信(读/写)的UI组件包装生成容器组件\n## 2. 通过redux管理头部标题headTitle数据\n    1). action-types.js\n    2). actoins.js\n    3). reducer.js\n    4). 相关组件: \n        left-nav.js\n        header.js\n        \n## 3. 通过redux管理登陆用户信息user数据\n    1). action-types.js\n    2). actoin.js\n    3). reducer.js\n    4). 相关组件: \n        login.js\n        admin.js\n        left-nav.js\n        header.js\n        role.js\n## 4. 自定义redux库\n    1). redux库向外暴露下面几个函数\n        createStore(): 接收的参数为reducer函数, 返回为store对象\n        combineReducers(): 接收包含n个reducer方法的对象, 返回一个新的reducer函数\n        applyMiddleware() // 暂不实现\n    \n    2). store对象的内部结构\n        getState(): 返回值为内部保存的state数据\n        dispatch(): 参数为action对象\n        subscribe(): 参数为监听内部state更新的回调函数\n    \n    3). combineReducers函数:\n        返回的总reducer函数内部会根据总的state和指定的action, \n        调用每个reducer函数得到对应的新的state, 并封装成一个新的总state对象返回\n## 5. 自定义react-redux库\n    1). react-redux向外暴露了2个API\n        a. Provider组件类\n        b. connect函数\n    \n    2). Provider组件\n        接收store属性\n        通过context将store暴露给所有的容器子组件\n        Provider原样渲染其所有标签子节点\n        \n    3). connect函数\n        接收2个参数: mapStateToProps和mapDispatchToProps\n        connect()执行的返回值为一个高阶组件: 包装UI组件, 返回一个新的容器组件\n        mapStateToProps: \n            为一个函数, 返回包含n个一般属性对象, \n            容器组件中调用得到对象后, 初始化为容器组件的初始状态, 并指定为UI组件标签的一般属性\n        mapDispatchToProps:\n            如果为函数, 调用得到包含n个dispatch方法的对象\n            如果为对象, 遍历封装成包含n个dispatch方法的对象\n            将包含n个dispatch方法的对象分别作为函数属性传入UI组件\n        通过store绑定state变化的监听, 在回调函数中根据store中最新的state数据更新容器组件状态, 从而更新UI组件\n# day11\n## 1. 数据可视化\n    1). echarts(百度) ==> echarts-for-react\n    2). g2(阿里) ==> bizCharts\n    3). d3(国外)\n## 2. 前台404界面\n    <Redirect from='/' to='/home' exact/>\n    <Route component={NotFound}/>\n    \n## 3. 打包应用运行\n    1). 解决生产环境ajax跨域问题\n        使用nginx的反向代理解决(一般由后台配置)\n        CORS: 允许浏览器端跨域\n    2). BrowserRouter模式刷新404的问题\n        a. 问题: 刷新某个路由路径时, 会出现404的错误\n        b. 原因: 项目根路径后的path路径会被当作后台路由路径, 去请求对应的后台路由, 但没有\n        c. 解决: 使用自定义中间件去读取返回index页面展现\n\n\n\t1. 创建项目\n\t2. npm start 测试运行\n\t3. postman测试接口\n\t4. 测试打包\n\t5. 用serve库 测试上线\n\t6. git版本控制\n\t7. ignore中 注意 idea node_module build 不需要版本控制\n\t8. antd 库，注意按需打包\n\t9. 表单 ： 1.前台表单验证 2.搜集表单数据 输入校验和点击提交时同一校验\n\t10. 发请求 封装axios\n\t11. 封装 接口请求函数\n\t12. async await消除回调地狱  async写在 await\n\t13. 注册二级路由 admin 参考react\n\t14. 设置路由链接 navLeft\n动态遍历菜单 config/menuConfig.js 里面存着数据 同时权限管理也需要这个\\\n\n\t\t\t数据里存对象，没children的是item，有children的是 submenu，submenu的children里存的是每个item\n\t1. map+递归 动态生成\n\t2. 根据path设置自动选中效果, 但是地址为/时，不会选中/home\n\t3. 路由组件三大属性 history location match\n\t\t\t\tusenavigate  uselocation\nantd 菜单 默认选中，刷新选中和展开问题\n\n伪元素 边框画三角形 \n&::after{\n\t                content: '';\n\t                position: absolute;\n\t                //相对开启定位的父元素的50%\n\t                right:50%;\n\t                top: 100%;\n\t                // 在移动自身50%\n\t                transform: translateX(50%);\n\t                border-top: 20px solid #fff;\n\t                border-right: 20px solid transparent;\n\t                border-bottom: 20px solid transparent;\n\t                border-left: 20px solid transparent;\n\t            }    \n\t2. 获取天气\n\t3. 封装时间组件\n\t4. 动态渲染首页字段，雷同之前的leftnav\n\t5. antd 对话框modal\n\t6. a标签 用javascript:;会报错，自己封装 LinkBottom \n\n品类管理 用antd的card 内容区用table\n\t分类有2级\n\t1. 测试接口 定义接口请求函数\n\t2. 动态显示一级列表 请求-数据存到状态\n\n")])])]),t("h2",{attrs:{id:"跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[n._v("#")]),n._v(" 跨域")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\tJSONP\n\t由于浏览器同源策略的限制，网页中无法通过Ajax请求非同源的接口数据。\n\t但是script标签不受同源策略的影响，可以通过src属性，请求非同源的js脚本\n\n\t<script src="./js/getdata.js"?callback=fn>>\n\t<\/script>\n\n\tfunction fn(data){\n\t\tconst result = data;\n\t}\n\n\t缺点：仅支持GET\n\t注意：JSONP和Ajax之前没有任何关系\n\t不能把JSONP请求数据方式叫做Ajax，因为它没有用到XMLHttpRequest这个对象\n')])])]),t("h2",{attrs:{id:"list组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list组件"}},[n._v("#")]),n._v(" list组件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1. isFirst 是否第一次加载\n2. isLoading \n3. error\n")])])]),t("h2",{attrs:{id:"高阶函数和函数科里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数和函数科里化"}},[n._v("#")]),n._v(" 高阶函数和函数科里化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\t高阶函数：满足以下任一\n\t1. 接收的参数是一个函数\n\t2. 返回值是一个函数\n\t常见的高阶函数有:Promise setTimeout arr.map()\n\n\t函数科里化：通过函数调用继续返回函数的方式，实现多次接受参数，最终统一处理\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);