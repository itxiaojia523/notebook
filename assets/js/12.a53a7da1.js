(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{418:function(n,a,t){"use strict";t.r(a);var e=t(2),s=Object(e.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[n._v("#")]),n._v(" 安装")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("JDK:java工具包\n\t= JRE + java开发工具(javac, java, javadoc… 编译运行等)\nJRE:java运行环境\n\t= JVM(虚拟机) + java核心库 rt.jar\n\n1. 安装JDK和JRE\n\toracle.com\n\t他们说直接下最新的就行 development kit 17 包含了jre\n\tJDK 1.8 用的也多 稳定\n\thttps://docs.oracle.com/javase/8/docs/api/\n\tAPI文档 \n\t\n\tJDK8或者JDK1.8是由于自从JDK1.5/JDK5命名方式改变后遗留的新旧命令方式问题，所以JDK8或者JDK1.8也是同一个东西。\n\t为了linux 还要装jre\n\t注意是否还要装JRE\n\tbin是开发工具，里面javac 编译的命令 java解析运行命令 javadoc\n\tjvm：java虚拟机 实现跨平台，不同的os、jvm不同 最终jdk不同\n\t\n2. 环境变量\n①定义JAVA_HOME：bin目录的上级目录 \n②在PATH中追加%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin\n\n注意：java版本切换\n修改了java home之后\n把path中的%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin 上移到最上面 重启cmd\n")])])]),a("p",[a("img",{attrs:{src:"/assets/imgs/1.png",alt:"这是图片",title:"Magic Gardens"}})]),n._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Java之前几乎没有语言将目标专注于客服开发与维护程序的复杂性\n最终导致项目复杂，难以维护\nC++选择向后兼容C，以及具有C一样的高效，但暴露更多的复杂性问题\n\nVisual Basic VB选择与Basic绑在一起，结果建立在VB纸上的所有扩展导致无法维护的语法\n\nperl向后兼容awk sed grep 以及所有它打算代替Unix工具，结果Perl程序变成了不可阅读的代码\n\n设计师们也都为了解决复杂性问题做了某种程度的工作。并且正是解决某类特定问题的能力，成就了它们的成功\n\nJava为程序员减少了复杂性，关心的是减少开发健壮代码所需的时间和困难\n早期这个目标使得代码运行并不快，现在Java程序运行效率已经改善了\n但它显著缩短了开发时间与C++开发相比，只需一半甚至更少的开发时间\n且开始着手各种复杂任务，如多线程，网络编程，并作为语言特性或者工具库的形式纳入Java\n且解决了一些相当大的复杂性问题：跨平台，动态代码修改，甚至是安全的议题\n")])])]),a("h2",{attrs:{id:"对象导论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象导论"}},[n._v("#")]),n._v(" 对象导论")]),n._v(" "),a("h3",{attrs:{id:"抽象过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象过程"}},[n._v("#")]),n._v(" 抽象过程")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('OOP Object-oriented Programming 面向对象编程\n所有编程语言都提供了抽象机制，可以认为，人们所能解决的问题的发咋行直接取决于抽象的类型(所抽象的是什么)和质量\n\n汇编语言是对底层机器的轻微抽象\n所谓的命令式语言如FORTRAN BASIC C等都是对汇编语言的抽象\n这些语言在汇编语言的基础上有了大幅的改进，但是所作的主要抽象仍要求基础计算机的结构，而不是基于问题的结构来考虑\n程序员必须建立起在机器模型和实际待解问题的模型(如业务)之间的关联。这种映射是费力的，而且这不属于编程语言所固有的功能，使得程序难以编写，且维护代价高昂\n\n另一种对机器建模的方式就是只针对待解决问题建模。\n早期的LISP和APL都选择考虑世界的某种特定视图(分别是"所有问题最终都是列表"或"所有问题都是算法形式") \nPROLOG则将所有问题都转换成决策链。此外还产生饿了基于约束条件变成的语言和专门通过对图形符号操作来实现变成的语言(后者被证明限制性过强)\n这些方式对它们所要解决的特定的类型的问题都是不错的方案。但一旦超过其特定领域，就力不从心了\n\nOOP雨荨根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。\n每个对象看起来都像一台计算机---它具有状态，还具有操作，用户可以要求对象执行这些操作。\n\nSmalltalk(Java所基于的语言之一)的五个基本特性\n1.万物皆为对象\n2.程序是对象的集合，通过发送消息来告知彼此所要做的。（对象的方法）\n3.每个对象都有自己的由其他对象所构成的存储\n可以通过创建包含现有对象的包的方式来创建新类型对象。因此，可以在程序中构建复杂的体系，同时将复杂性隐藏在对象的简单性背后\n4. 每个对象都有其类型Class. 每个对象都是某个class的实例instance\n每个类区别于其他类的特性就是：可以发送什么样的消息给它\n5. 某一特定类型的所有对象都可以接收同样的消息\n\n因为类描述了具有相同特性(数据元素)和行为(功能)的对象集合\n实际上就是一个数据类型\n浮点型数字具有相同的特性和行为集合\n差异在于，程序员通过定义类来适应问题，而不是被迫只能使用现有的用来表示机器中的存储单元的数据类型\n\n类型Light 接口 on() off() brighten() dim（）\n那么Light的实例对象就必须满足这些接口\n')])])]),a("h3",{attrs:{id:"服务提供者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务提供者"}},[n._v("#")]),n._v(" 服务提供者")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('在试图开发或理解一个程序设计时，最好的方法之一就是将对象想象为服务提供者。\n"如果可以将问题从表象中提取出来，那么什么样的对象可以马上解决我的问题呢？"\nex. 簿记系统\n1.预定义的簿记输入屏幕的对象\n2.执行簿记计算的对象集合\n3.一个处理在不同打印机上打印支票和开发票的对象\n某些可能已经存在了，那么对于不存在的对象，它们看起来像什么？能提供哪些服务？需要哪些对象才能旅行它们的义务？\n有助于提高对象的内聚性。\n以上是高内聚\n如果将过多的功能都塞在一个对象中。就出现高耦合\n高内聚低耦合是高质量代码的基本要求之一。\nex. 在检查打印模式的模块中，你想让它了解所有的格式和打印技术。\n你可能需要三个甚至更多个对象。\n1. 所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息\n2. 一个通用的打印接口，知道所有不同类型的打印机的信息\n3. 第三个对象通过调用另外两个对象的服务来完成打印任务\n这样每个对象都有一个它所能提供服务的内聚的集合。\n每个对象都可以很好的完成一项任务，但是它并不试图做更多的事。\n')])])]),a("h3",{attrs:{id:"被隐藏的具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被隐藏的具体实现"}},[n._v("#")]),n._v(" 被隐藏的具体实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("将开发人员按角色分为类创建者和客户端程序员（消费者）\n类的创建者的目标就是构建类，这种类只像客户端程序员暴露必须的部分，而隐藏具体实现\n理由是，如果隐藏，那么消费者就不能访问。同时意味着创建者可以任意修改隐藏的部分，而不必担心对使用者造成影响\n同时一般隐藏的部分是脆弱的部分可以减少bug\n\n访问控制：暴露必须的，隐藏具体实现\n关键字 public private protected\n")])])]),a("h3",{attrs:{id:"复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复用"}},[n._v("#")]),n._v(" 复用")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("产生一个可复用的对象设计需要丰富的经验和敏锐的洞察力\n一旦类创建并测试完，在理想的情况下就代表一个有用的代码单元。\n但事实上，这种复用性并不容易达到所希望的那种程度\n\n最简单的复用就是直接使用类的实例对象\n也可以将某个类的一个对象放置于某个新的类中。称为“创建成员对象”，是一种称为组合composition的概念\n\n如果组合是动态放生的，则通常被称为聚合aggregation\n\n组合经常被视为has-a关系。如汽车拥有引擎\n组合带来了极大的灵活性。新类的成员对象通常都是private\n\n继承不具备这样的灵活性，因为编译器必须对通过继承而创建的类施加编译时的限制\n\n在建立新类时，优先考虑组合，因为更加简单灵活。\n")])])]),a("h3",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[n._v("#")]),n._v(" 继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("创建一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类\n\n可以通过继承，以现有的类为基础，复制一份，通过添加和修改来修改这个副本\n注意：实际上并不是副本，而是引用。基类/源类/超类/父类发生变动时，会影响继承类/导出类/子类也会反映这些变动\n\nShape : draw（） erase()\nCircle Square Triangle extends Shape\n继承以后，即便子类里没有定义方法，它可以引用到父类的方法\n\n两种方法可以使得基类和导出类产生差异\n1.在导出类中添加新方法\nTriangle flipVertical()\n这意味着基类不能直接满足你的所有需求，因此必须添加更多的方法。\n这种简单而基本的使用方式，有时对问题来说确实是一个完美的解决方式\n\n第二种改变基类的方法的行为，称之为覆盖overriding\n在导出类中定义与基类相同得方法\n可以说：我正在使用相同得接口，但是想要在新类中做些不同的事情\nCircle draw()\nSquare draw()\nTrangle draw()\n子类中有就优先调用子类的\n\n\nis-a 和 is-like-a\n某种争论：继承应该只覆盖基类的方法吗\n1. 如果只覆盖基类的方法，就意味着导出类和基类是完全相同得类型，因为它们具有完全相同得接口。\n结果可以用一个导出类对象来完全代替一个基类对象。\n可以视为纯粹代替，通常称为替代原则\n某种程度上，是一种处理继承的理想方式\nis-a关系：圆形是一个几何形 \n\n有时候必须在导出类型中添加新的接口元素。这个新类型仍然可以代替基类，但是这种代替并不完美。因为基类无法访问新添加的方法。\nis-like-a关系\n新类具有旧类型的接口，但是它还包含其他接口\n\nCooling System制冷系统 cool()\nAir Conditioner ,Heat Pump extends Cooling System\nAir Conditioner cool()\nHeat Pump cool() heat()\n看完这个后，会显然发现CS这个基类不够一般化。应该改为温度控制系统，是它包括制热功能。这样我们就可以套用替代原则了\n")])])]),a("h3",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[n._v("#")]),n._v(" 多态")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("站在子类角度是继承\n站在父类角度是多态\n\n在处理类型时，经常想把一个对象不当做它所属的特定类型来对待，而是将其当做基类对象来对待。\n使得可以写出不依赖于特定类型的代码。\n几何形中定义的方法，不需要考虑实际是正方形还是三角形\n\nBirdController reLocate()\nBird move()\nGoose move()\nPenguin move()\n\nPenguin, Goose extends Bird\nBirdController对象仅仅处理泛化的Bird对象，而不需要知道具体是Goose还是Penguin\n当调用move()时发生了什么。move调用时，即便忽视Bird的具体类型，也会正确调用Goose的飞 Penguin的走呢\n\n答案：编译器不可能产生传统意义上的函数调用。\n\n非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定。\n这意味着编译器将产生对一个具体的函数名字的调用，运行时，将这个调用解析到要被执行的代码的绝对地址。\n\n然而在OOP中，程序运行时，才能确定代码的位置。\n采用后期绑定的概念。\n编译器确保被调用方法的存在，并对调用参数和返回值进行类型检查。\n但是并不知道被执行的确切代码\n无法做类型检查的语言成为弱类型语言\n\n为了执行后期绑定，Java使用一小段特殊的代码来代替绝对地址调用。（第八章）\n这段代码使用在对象中存储的信息来计算方法体的地址。\n这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送信息时，该对象就能够知道对这条消息应该做什么\n\n在某些语言钟。如C++是通过virtual关键字实现后期绑定\nJava默认后期绑定\n\n正因为多态\nvoid doSomething(Shape shapre){\n\tshapre.erase() //真正调用的时候circle 和 line又是不一样的\n}\n\ndoSomething(circle)\ndoSomething(triangle)\ndoSomething(line)\nCircle Triangle Line 类型是Shape的子类，可以代替Shape作为参数放入\n把子类当做父类，叫向上转型upcasting\n\n")])])]),a("h3",{attrs:{id:"单根继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单根继承"}},[n._v("#")]),n._v(" 单根继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("基本上所有OOP语言除C++，所有类最终都继承单一基类。Object\n所有对象都具有一个共用接口\n\nC++多继承，能够更好地适应C模型，而且受限较少。\n但要进行完全的OOP时，必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在任何新类库中，总会用到一些不兼容的接口，需要花力气有可能通过多继承来使得新接口融入你的设计之中。\n这么做来换取C++额外的灵活性是否值得呢？\n如果在C上面投资巨大的话，这么做就很有价值。\n如果从头开始Java这样的选择通常有更高的生产率\n\n单继承使得垃圾回收器的实现变得容易得多。\n垃圾回收器是Java相对C++的重要改进之一\n且由于队友对象都保证具有其类型信息，因此不会因为无法确认对象的类型陷入僵局。这对于系统级操作如异常处理显得尤其重要。\n")])])]),a("h3",{attrs:{id:"容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[n._v("#")]),n._v(" 容器")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("通常来说，如果不知道解决特定问题需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。\n如何才能知道需要多少空间来创建这些对象呢？---不可能知道，因为只有运行时才能获得。\n\n这个问题的解决方案似乎显得轻率：创建另一种对象类型。\n这种类型持有对其他对象的引用。\n当然也可以用在大多数语言钟都有的数组类型来实现相同的功能。\n\n通常这个类型被称为容器。也称为集合。\n在任何需要时都可以扩充自己以容纳你放置的所有东西。\n\n幸运的是，好的OOP语言都有一组容器，作为开发包的一部分。\n在C++中，容器是标准库的一部分。\nJava在其标准库中也含有大量容器\n在某些类库中，一两个通用容器就足够满足所有需求了。\n但在其他类库，如Java中，具有满足不同需要的各种类型的容器\nList Map set,以及诸如队列，树，堆栈等更多的构件\n\n从设计的观点来看，真正需要的只是一个可以被操作，从而解决问题的序列。\n好像没有理由设计不同种类的序列。\n但这是需要的\n原因1：不同容器提供了不同类型的接口和外部行为\n堆栈相比队列就具有不同的接口和行为，也不同于集合和列表\n它们之中的某种容器提供的方案可能更加灵活\n\n原因2：不同的容器对某些具体操作具有不同的效率\nex. 两种List ArrayList 和 LinkedList\nArrayList 随机访问元素时是固定时间\nLinkedList：随机访问元素时越靠近表尾的元素，花费时间越长，在序列中插入某一个元素时，开销更小\n\n")])])]),a("h3",{attrs:{id:"参数化类型-泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数化类型-泛型"}},[n._v("#")]),n._v(" 参数化类型 泛型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("SE5之前，容器存储的对象都是通用类型Object。\n单继承的结构使得可以存储Object的容器可以存储任何东西\n\n但是因为只能存Object，所以存入时必须被向上转型为Object，因此它会丢失其身份（如Circle），当它取回时，就获取了一个Object对象的引用，而不是Circle类型的对象的引用。\n那么如何变换回来呢？\n\n向上转型是安全的\n除非确切知道类型，否则向下转型几乎是不安全的\n当然也并非彻底是危险的，如果转错了，会得到异常\n即便如此，必须要知道原本的类型，才能正确的向下转型\n如何做呢？\n\n那么创建一个知道自己所保存的对象的类型，从而不需要向下转型以及消除犯错的可能的容器---这个解决方案交错参数化类型机制\n\n参数化类型机制是一个编译器可以自动定制作用域特定类型上的类。\nex. 可以定制一个只接纳和取出Shape对象的容器\n\nSE5重大变化之一就是参数化类型，Java中成为泛型<>\nArrayList<Shape> shapres = new ArrayList<Shape>()\n\n")])])]),a("h3",{attrs:{id:"对象的创建和生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建和生命周期"}},[n._v("#")]),n._v(" 对象的创建和生命周期")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("使用对象时，最关键的问题之一便是它们的生成和销毁方式。\n每个对象为了生存都需要资源，尤其是内存。当不再需要时，必须被清理掉。\n在相对简单的变成情况下，手动清理看起来似乎不是什么挑战。\n\n但是复杂的情况下，如为机场设计空中交通管理系统\n1. 创建一个鞥器保存所有飞机\n2. 进入管控区的飞机创建一个飞机对象，放置于容器中\n3. 离开此区域后，删除相关的飞机对象\n\n但是可能别的系统也记录着有关飞机的数据，这些数据不需要像上面那样立刻就能注意。\n如记录所有飞离机场的小型飞机的飞行计划，你需要第二个容器来存放小型飞机。\n无论何时只要创建的是小型飞机的对象，它同时也要被存入这个第二个容器中。\n然后某个后台进程在空闲时对第二个容器内对象进行操作。\n\n当处理完某个对象之后，其他部分可能还在处理它。\n怎样才能知道何时销毁呢？\n在C++，这个问题会变得非常复杂。\nC++ 认为效率控制是最重要的。所以给程序员选择的权利。对象的存储空就生命周期可以在编程时确定。\n可以将对象放在堆栈或静态存储区内来实现。\n这种方式将存储空间分配和释放位于优先考虑的位置，某些情况下这样控制非常有价值。但是牺牲了灵活性。因为必须在编写的时候知道对象确切的数量，生命周期和类型。\n\n第二种方式就是再堆的内存池中动态地创建对象。只有在运行时才能确定需要多少对象。如果需要一个新对象，可以在需要的时候直接在堆里创建。\n因为存储空间是被动态管理的，所以需要大量的时间在堆中分配存储空间。\n这可能远远大于在堆栈中创建存储空间的时间。\n\n堆栈中创建存储空间和释放存储空间通常各需要一条汇编指令即可，分别将栈顶指针向下移动和栈顶指针向上移动\n\n创建堆存储空间的时间依赖于存储机制的设计\n\n动态方式有这样一个一般性逻辑假设：对象趋于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。\n\nJava完全采用了动态内存分配方式。通过new关键字创建对象\n\n关于对象生命周期\n对于允许在堆栈上创建对象的语言，编译器可以确定对象存货的时间，并且可以自动销毁。\n\n如果是堆上创建对象，编译器就会对它的生命周期一无所知。在像C++这样的语言钟，必须通过编程的方式来确定何时销毁。\n常见的内存泄漏问题\n\nJava提供了垃圾回收器机制，可以自动发现对象何时不再被使用，从而销毁它\n减少了必须考虑的议题和必须编写的代码。更主要的是表面暗藏的内存泄漏问题。\n很多C++死在这里。\n\n")])])]),a("h3",{attrs:{id:"异常处理-错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常处理-错误处理"}},[n._v("#")]),n._v(" 异常处理：错误处理")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("自从变成语言问世以来。错处处理始终是最困难的问题之一。\n因为设计一个好的错误处理机制很困难。很多语言直接略去了这个问题，让程序员设计者处理。\n设计者也只是提出一些不彻底地方法，这些方法适用于一些容易避免此错误的场合，而且解决方式通常也只是忽略此问题。\n依赖于程序员自身的警惕性。而不是语言所强制的。\n\n异常处理，将错误处理直接置于语言钟，甚至有时在OS中。\n异常是一个对象，它从出错地点被抛出，并被异常处理器捕获。\n异常处理和程序正常执行路径并行，不干扰正常的执行代码。\n使得代码编写变得更加简单。\n\n此外异常不能被忽略，它保证一定会被某处得到处理\n提供了一种从错误状态进行可靠恢复的途径。不再是只能退出程序，你可以经常进行校正，并恢复程序的执行。有助于编写出更健壮的程序\n\n值得注意的是，异常处理不是面向对象的特征。在OOP之前就已经存在了，尽管在OOP中尝尝被表示成一个对象\n")])])]),a("h3",{attrs:{id:"并发编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[n._v("#")]),n._v(" 并发编程")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("在同一时刻处理多个任务的思想。\n许多程序设计都要求，程序可以停下正在做的工作，转而处理某个其他问题，再返回。\n很多方法可以实现\n最初是根据程序员掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件来触发\n但是难度太大，不能移植。移到新型号机器上时，费时费力\n\n有时中断对于处理时间性强的任务是必须的，但是对于大部分的其他问题，我们只是想要将问题切分成多个可以独立运行的部分(任务)，从而提高程序的响应能力。\n这些独立运行的任务叫做线程\n\n上线的概念被称作并发。\n\n通常线程只是一种为单一处理器分配执行时间的手段。\n如果是多核的话每个任务都可以被指派给不同的处理器，这样才是真正的并行执行。\n\n程序员不用关心机器是不是多核。只要逻辑上是并行处理，如果机器有多核，自动适应\n\n隐患：共享资源。如果并行任务同一时间都要访问同一项资源，那么就会出现问题。\n通过锁\n某个任务锁定某项资源，完成其任务，然后释放资源锁之后，其他任务才可以使用\n\n")])])]),a("h3",{attrs:{id:"java和internet"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java和internet"}},[n._v("#")]),n._v(" Java和Internet")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("为什么Java这么重要，促进了语言向前迈进了革命性一步。\n不单单解决了传统的单机程序设计问题，还解决了万维网上的程序设计问题。\n\n客户端与服务器\n\n客户端编程\n最初都是静态页面，交互性都是后端搞，数据给后端，后端返回新的html页面\n基本的HTML具有数据手机机制，表单提交通过通用网关接口common gateway interface CGI传递。\n最常见的动作就是运行一个在服务器中被命名为cgi-bin的目录下的一个程序\n\n当点击了提交按钮，url里有cgi-bin\n\n几乎所有语言都可以实现，Perl是最常见的，因为它被设计用来处理文本，并且是解释型语言。无论服务器的处理器和OS如何，都始于安装\nPython更强大和简单\n\n很多有影响力的网站完全构建于CGI之上。\n事实上CGI几乎可以做任何事，但是构建于CGI程序之上的网站可能会迅速变得过于复杂难以维护，响应慢\nCGI程序的响应时间依赖于 数据量大小，服务器和Internet的负载\n启动CGI程序也很慢\n\n同时，web最初的设计师没有预见网络带宽被人们开发的APP迅速耗尽。\nex. \n动态图形处理几乎不可能连贯\n表单验证要先发送给服务器，然后服务器启动CGI程序检查，发现错误，返回一个错误页面，你再后退一个页面，重新开始。\n不仅仅慢，而且不优雅\n\n问题的解决方法就是客户端变成。\n\n大多数运行浏览器的机器都是能够执行大型任务的强有力的引擎。在静态HTML下，它们只是闲置在那里。\n\nweb开发，跟通常意义上的编程十分不同，参数几乎相同，但是平台不一样。\n浏览器就像一个功能受限的OS。\n\n客户端所迈出的最重要一步就是插件plug-in的开发。\n程序员可以下载一段代码，并将其插入浏览器中适当的位置，以此来为浏览器添加新功能。\n意义在于：允许程序员不需要经过浏览器生产厂商的絮语，就可以开发某种语言的拓展，并将它们添加到服务器中。\n插件提供了一个后门，使得可以创建新的客户端编程语言。\n并非所有客户端编程语言都是插件形式\n\n脚本语言\n插件引发了浏览器脚本语言的开发scripting language。\n通过它，你可以将客户端程序的源代码直接嵌入到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。\n易于理解，因为它们只是作为HTML页面一部分的简单文本。当服务器收到要获取该页面的请求时，可以被快速加载。\n缺点是代码会暴露给任何人取浏览。\n通常不会用脚本语言取做相当复杂的事情，所以问题不大。\n\n如果期望一种脚本语言在浏览器，不需要任何插件的情况下就可以得到支持，那它就是JavaScrpt了\n\n大多数浏览器最初都是以不同的方式实现对JavaScript的支持，甚至存在于同一浏览器的不同版本之间。\n\n以ECMAScrpt的形式实现的JavaScript的标准化有助于此问题的解决。\n但不同的浏览器为了跟上这一标准趋势就花费了相当长的时间。\n且微软一直在推它自己的VBScript形式的标准\n\n在浏览器内部使用的脚本语言实际上总是被用来解决特定类型的问题。\n主要就是用来创建更丰富，更具有交互性GUI 图形化用户界面。\n脚本语言可以解决客户端编程的80%问题。\n剩下的20%就得靠Java了\n\n强大，安全，跨平台，国际化，且不断被扩展。\n并发，数据库访问，网络变成，分布式计算等等。\n\nJava是通过applet以及使用Java Web Start来进行客户端编程的。\napplet只是Web浏览器中运行的小程序，它作为网页的一部分自动下载的，就像是图片一般。\n当被激活时，便开始执行一个程序，这正是它优雅之处。提供一种分发软件的方法。一旦用户需要客户端软件时，自动从服务器发给用户。用户获得最新版本的客户端软件时不会产生错误，而且也不需要麻烦的重新安装\n\nJava的这种设计使得程序员只需要创建单一的程序，只需要这台机器有浏览器，且浏览器具有内置的Java解释器，大多数机器都如此。那么这个程序就可以自动在这台计算机上运行。\n\n由于java是一种程序的语言。所以在请求之前和之后，可以在客户端尽可能多地做些事情。\n比如不必跨网络地发送表单来检查自己是否填写错误的日期或其他参数。客户端自己就能快速的标出错误。\n\njava applet实际上没有达到当初所吹嘘的境界。\nweb上确实存在一些非常灵巧的applet。但是压倒性迁移却没有发生。\n最大问题可能在于安装JRE需要10M带宽对一般用户已经过于恐怖\n且微软没有选在IE中包含JRE\n\napplet适用于企业内部，特别是需要频繁的更新的时候\n\n一个这种的新技术。Macromedia的Flex\n允许你创建基于Flash的与applet相当的应用。\n因为Flash Player在超过98%的浏览器上都可用。且跨OS，是事实上的标准。\n安装和更新Flash都很快捷。\nActionScript也是基于ECMAScript\n但是Flex使我们在变成时，不用担心跨浏览器，因此比JS要新引人。\n\n.NET 和 C#\njava applet的主要竞争对手是微软的ActiveX. 尽管它要求客户端必须运行Windows平台。\n此后微软退出.NET平台和C#变成语言的形式与Java全面竞争\n.NET相当于JVM和Java类库，C#类似Java。在Java之后，所以它们可以看到Java在什么地方做得好，什么地方不够好，取构建。\n.NET最受关心的问题是，微软是否允许它完全跨平台。\n宣城是这么做没问题。但目前只是在Linux上部分实现.NET\n仍然是高风险\n\nInternet和Intranet公司内部网\n如果程序运行在internet上，你就不知道它会被运行在什么样的平台上。\n因此你需要跨平台，安全的语言，就像脚本语言和Java。\n更要注重代码安全没有bug\n\nIntranet更高的安全性，可以物理控制对公司内部服务器的访问。\n内部网，你可以对自己代码质量负责，并且可以在发现bug后修复它。\n此外可能还有更传统的客户端/服务器方式编写的遗留代码，因此每一次升级都要物理地重装客户端程序。\n在安装升级程序时，所浪费的时间是迁移到浏览器方式上的最主要的原因。\n在浏览器方式下，升级是透明的自动的。\n\n服务器端编程\n当收到客户端的请求后，发生什么呢？\n比如请求是给我发送一个文件。\n浏览器会以某种适当的形式解释这个文件，例如它是HTML页面，还是图片，还是java applet或脚本程序来解释。\n\n更复杂的请求通常设计到数据库事务。\n涉及到对数据库的修改，对数据库的操作就是所谓的服务器端编程。\n\n过去服务器端编程时通过Perl Python C++ 或 其他CGI\n但造成了更加复杂的系统。包括Java的web服务器\n它让你用Java编写被称为servelet的程序来实现服务器端编程。\nservlet和衍生物JSP是许多网站迁移到java的主要原因。\n\n")])])]),a("h2",{attrs:{id:"一切都是对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一切都是对象"}},[n._v("#")]),n._v(" 一切都是对象")]),n._v(" "),a("h3",{attrs:{id:"用引用操纵对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用引用操纵对象"}},[n._v("#")]),n._v(" 用引用操纵对象")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('java是基于c++的，但它是一种更纯粹的面向对象程序设计语言\nc++和java都是混合/杂合型语言。但java认为这种杂合性并不像c++中name重要。\n杂合型语言允许多种编程风格。c++之所以成为一种杂合型语言主要是为了支持C。是C的一个超集，势必包括许多C没有的特性，使得C++在某些方面过于复杂\n\n每种语言都有自己操作内存中元素的方式。\n必须注意数据是什么类型。\n是直接操纵元素，还是用某种基于特殊语法的间接表示（如c和c++中的指针）\n\n这一些得到简化，因为一切都是对象，因此可采用单一固定的语法。\n注意 标识符实际上是对象的一个引用reference.\n遥控器(引用)和电视机(对象)\nString s = "123"\n\ns是引用 "123"是对象\n\n简单理解成指针也行，不过java中的引用语法书更接近c++的引用而不是指针\n\n通过new关键字来创建一个对象\nString s = new String("abc")\n\n存储位置\n程序运行时候，对象是怎么进行安排放置的，特别是内存是如何分配的？\n\n1. 寄存器\n最快！ 因为它位于处理器内部(与其他存储区不一样)\n但是数量有限，所以一般都是按需分配，程序员不能直接控制，在程序中也感觉不到它的存在。\n在C和C++中允许你向编译器建议寄存器的分配方式\n\n2. 堆栈\n位于RAM\n堆栈指针可以从处理器那里直接获得支持。\n指针向下移动，分配新内存\n向上移动，释放内存\n快速有效，仅次于寄存器\n但是必须知道存储在堆栈内所有项的生命周期才能便于上下移动堆栈指针。\n限制了程序的灵活性\n所以对象不能存储在这里。\n而对象的引用存在这边\n\n3. 堆\n存放对象\n不同于堆栈：编译器不需要知道存储的数据再堆里活了多久。因此在堆里分配空间有很大灵活器。需要对象时，new以下。\n代价是，用堆进行存储分配和清理，可能比用堆栈需要更多时间\n\n4. 常量存储\n通常直接存放在程序代码内部，这么做是安全的，永远不会被改变。\n有时嵌入式系统，常量本身会与其他部分分隔开，这时候可以选择存在ROM 只读存储器。\n\n5. 非RAM存储\n数据完全存活于程序之外。在程序没有运行时，也能存在。\n基本的例子就是流对象和持久化对象中\n在流对象中，对象转化成字节流，通常被发送给另外一台机器。\n在持久化对象中，对象被存放于磁盘上。\n在需要时，可以恢复成常规的，基于RAM的对象。\nJAVA提供了对轻量级持久化的支持，而JDBC和Hibernate等提供了更加复杂的对数据库里存储和读取对象信息的支持\n\n特例：基本类型\n\n因为对象存在堆里，因此当对象特别是小的，简单的变量，那么就不是很有效。\n对于基本类型，采取跟C和C++的相同方式，不用new来创建，而是将这个变量直接存值，放在堆栈中\n\njava中每种基本类型所占空间大小是一样的。\n这个不变性是更可移植性的原因之一。\n\n![这是图片](/assets/imgs/java/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png "基本类型")\n\n包装类使得基本类型，可以在堆中创建一个非基本对象，用来表现对应的基本类型\n\nex.\nchar c = \'x\'\nCharacter ch = new Character(c)\n或\nCharacter ch = new Character(\'x\')\n\nSE5 自动包装，自动将基本类型转为包装器类型\nCharacter ch = \'x\'\n也可以反转\nchar c = ch\n\njava中的数组\n几乎所有语言都支持数组。在C和C++中使用数组时危险的。\n因为它们的数组就是内存块。如果一个程序要访问自身内存块之外的数组，或者在初始化前使用（常见错误），都会产生难以预料的后果。\n\njava目标之一安全性。\n确保数组会被初始化。且不能再它范围之外被访问。\n这个范围检查，是以每个数组上少量的内存开销以及运行时的下标检查为代价。\n换来安全性和效率的提高，因此是值得的。\n且java有时可以优化这些操作\n\n创建一个数组，同样实际上就是创建了一个引用数组，每个引用都会自动被初始化一个特定值，该值拥有自己的关键字null。一旦看到nl，java就知道这个引用还没有指向某个对象。在使用任何引用前，必须为其指定一个对象。\n如果试图使用一个还是null的引用，那么运行时会报错。因此，常犯的错数组错误在java中就可以避免了。\n\n还可以创建基本数据类型的数组。同样编译器会保证它的初始化。因为它会将数组所占的内存全部置零\n\n')])])]),a("h3",{attrs:{id:"永远不要销毁对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#永远不要销毁对象"}},[n._v("#")]),n._v(" 永远不要销毁对象")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('大多数语言中，变量有生命周期概念。\njava是如何替我们完成所有的清理工作。\n\n作用域\nc c++ java中作用域由{}的位置决定\n\n在c c++可以这么写 在Java里不允许重复声明\n\n{\n\tint x = 12\n\t{\n\t\t//在c 和c++里将较大作用域的变量隐藏起来的做法\n\t\tint x = 96\n\t}\n}\n\n对象的作用域\n{\n\tString s = new String("a string")\n} // end of scope\n引用s在作用域终点就消失了\n但是这个对象还在内存里\n无法通过作用域之外访问这个对象\n\n由new 创建的对象，只要你需要就会一直保留下去\n汝城保证不会填满内存空间呢---垃圾回收器\n\n它监视用new创建的所有对象，并辨别那些不再被引用的。\n一旦不被需要，它们会自行消失\n笑出了内存泄漏问题\n\n')])])]),a("h3",{attrs:{id:"类-创建新的数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类-创建新的数据类型"}},[n._v("#")]),n._v(" 类：创建新的数据类型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("如果一切都是对象，那么用什么决定某一类对象的外观和行为呢？\n换句话说，它们的类型是什么\n你可能期望有一个名为type的关键字\n但又历史发展角度来说，大多数OOP习惯用class这个关键字\n\nclass ATypeName{ //class body goes here }\n尽管里面什么都没，但是你已经可以用new来创建这类型的对象了\nATypeName a = new ATypeName();\n\n字段和方法\n\n在类中可以设置两种类型的元素\n字段和方法\n\n字段/数据成员  可以是任何类型的对象也可以是基本类型\n\t如果是堆某个对象的引用，那么必须初始化该引用\n\nclass DataOnly{\n\tint i;\n\tdouble d;\n\tboolean b;\n}\nDataOnly data = new DataOnly()\ndata.i = 47\ndata.d = 1.1\ndata.b = false\n\n想修改的数组可能位于对象所包含的其他对象中，只需要再.就行\nmyPlane.leftTank.capacity = 100\n\n基本成员默认值\n如果某个成员是基本数据类型，即使没有初始化，java也会确保它有一个默认值，反之程序错误。c++没有此功能\n\n基本类型 默认值\nboolean\tfalse\nchar\t'反斜杆uoooo'(null)\nbyte\t(byte)0\nshort\t(short)0\nint\t\t0\nlong\t0L\nfloat\t0.0f\ndouble\t0.0d\n\n因为默认初始值，可能是不正确或不合法的\n所以最好显示声明\n\n这个确实还方法不适用于局部变量（并非某个类的字段）\n比如在方法里定义的\nint x;\n这个变量x得到的可能是任意值，而不会被自动初始化为0\n\n最佳实践：显示赋初始值\n\n方法/成员函数  \n方法 参数和返回值\n许多程序设计语言如c和c++用函数这个术语来描述子程序\n而在java里却常用方法这个术语来表示做某些事情的方式。\n实际上，看作函数也无妨\n\njava的方法决定了一个对象能接收什么样的消息。\n组成部分包括：名称 类型 返回值和方法体\n以下是最基本的形式\nReturnType methodName(//argument list){\n\t//method body\n}\n方法名和列表参数合起来称为方法签名唯一地表示出某个方法\n\njava中方法只能作为类的一部分来创建\n方法只用过对象才能调用\n如果试图调用这个对象不具备的方法，编译时会得到一条错误消息\n\n加入有一个a的对象有f方法，不带任何参数，返回值是int\n可以这样写\nint x = a.f()\n用x来接收返回值\n\n参数列表\n方法的参数列表指定传递给方法什么样的信息。同样这些信息采用的都是对象形式\n因此必须指定类型和名字，这里的传递实际上也是引用\n\nP60\n\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);