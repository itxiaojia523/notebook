(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{467:function(t,e,n){"use strict";n.r(e);var o=n(2),a=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react路由"}},[t._v("#")]),t._v(" React路由")]),t._v(" "),e("h2",{attrs:{id:"spa理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spa理解"}},[t._v("#")]),t._v(" SPA理解")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("SPA：single page application\n单页Web应用\n1. 整个应用只有一个页面\n2. 点击页面的链接，不会刷新页面，只会做局部更新\n3. 数据通过ajax请求获取，并在前端异步展示\n")])])]),e("h2",{attrs:{id:"路由的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由的理解"}},[t._v("#")]),t._v(" 路由的理解")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("一个路由就是一个映射关系key-value\nkey作为路径，value可能是function或component\n")])])]),e("h2",{attrs:{id:"前端路由和后端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端路由和后端路由"}},[t._v("#")]),t._v(" 前端路由和后端路由")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('前端路由：\n1. 浏览器路由 value是component 用于内容展示\n2. 注册路由<Route path="/test" component={Test}>\n3. 流程\n点击test链接按钮，url变成 xxx/test, 监控到url的变化，展示Test组件\n\n路由根据浏览器BOM的history\n\nhistory是栈结构\n\nreplace直接把栈顶的替换了\n\nlet history = History.createBrowserHistory() //方法1：直接使用H5推出的history的api\nlet history = History.createHashHistory() //方法2 hash值 锚点\n\n后端路由：\n1. value是function，用来处理前端提交的请求\n2. 注册路由 router.get(path,function(req,res))\n3. 流程\n当node接到一个请求时，根据url找到匹配的路由，调用回调\n')])])]),e("h2",{attrs:{id:"使用路由-v5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用路由-v5"}},[t._v("#")]),t._v(" 使用路由 v5")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('1. 需要额外下包\nnpm i react-router-dom\n\n2. 内置组件\n<BrowserRouter>\n<HashRouter>\n<Route> // v6 render 或 component 改为 element\n<Redirect>\n<Link>\n<Navlink>\n<Switch> // v6中已被移除，新增<Routes>\n\nhistory对象\nmatch对象\nwithRouter对象\n\n//在React中靠路由链接实现组件切换\n<BrowserRouter>\n    <Link to="/about">About</Link>\n    <Link to="/home">Home</Link>\n</BrowserRouter>\n//以上代码通过link标签，修改url,但目前页面不会更新\n\n//注册路由\n//通过Route注册路由，注册完后，可以监听到url变化，从而更新组件\n<BrowserRouter>\n    <Route path="/about" component={About}></Route>\n    <Route path="/home" component={Home}></Route>\n    //v6中 \n    <Route path="/home" element={<Home />}></Route>\n</BrowserRouter>\n\n整个App只需要一个<BrowserRouter>\n\nReactDOM.render(\n    <BrowserRouter>\n        <App/>\n    </BrowserRouter>\n)\n\n路由组件收到的props里有\nhistory\nmatch\nlocation\n\n<Navlink> 等同 <Link>\n什么时候使用：当需要动态追加类名时\n注意bootstrp的样式权重高，自己的样式需要提高权重\n\n.xiaojia{\n    background-color:orange !important\n    color:white !important\n}\nex.\n<Navlink activeClassName="xiaojia" to="/about">About</Navlink>\n\n<Switch> 单一匹配\n不添加的话，home能匹配到 2个，Home Test两个组件都将被渲染\n<Switch>\n    <Route path="/about" component={About}></Route>\n    <Route path="/home" component={Home}></Route>\n    <Route path="/home" component={Test}></Route>\n    //都匹配不上，走redirect，去about\n    <Redirect to="/about" />\n</Switch>\n\n//v6\n<Routes>\n    <Route path="/home" element={<Test />}></Route>\n    <Route path="/home" element={<Home />}></Route>\n</Routes>\n\n模糊匹配和严格匹配\n严格匹配不要用，能不用就不用,多级路由可能会出问题，有需要再开 \n默认：exact是false\n\n\n<Route exact={true} path="/about" component={About}></Route>\n<Route exact path="/about" component={About}></Route> // ={true} 可以省略\n\n默认是模糊匹配\n<Link to="/home/a/b">Home</Link>\n<Route path="/home" component={Home}></Route>\n\nlink是home/a/b 只要route里有home就能匹配上\n\n路由嵌套\n路由匹配顺序：\n先匹配 先注册的路由，顺序往里\n<Link to="/home/news">News</Link>\n<Route path="/home/news" component={News}></Route>\n\nv6\n// 路由嵌套\n<Route path="users" element={<Users />}>\n     <Route path="me" element={<OwnUserProfile />} />\n     <Route path=":id" element={<UserProfile />} /> \n</Route>\n显示 OwnUserProfile 组件的话通过 /users/me\n\n编程式路由导航\nwithRouter使得普通组件也能使用路由的api\nexport default withRouter(Header)\n借助this.props.history对象上的API对操作路由跳转，前进，后退\nthis.props.history \npush()\nreplace()\ngoBack()\ngoForward()\ngo()\n\n路由组件传参\nparams传参\nsearch传参\nstate传参\n\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("outlet显示子组件，如果没有outlet不会显示")])]),t._v(" "),e("h2",{attrs:{id:"最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 单独管理路由router.tsx\n\nimport {lazy, Suspense} from 'react'  //懒加载\nimport App from \"App\";\nimport {BrowserRouter, Routes, Route} from 'react-router-dom'\nimport Loading from 'components/Loading';\n// app 和 缓存ui 不需要懒加载\n// lazy(callback) callback中使用return import('Login')\n\ninterface Iroute {\n    path: string,\n    component: React.FC,\n    children?: Iroute[]\n}\nconst routerArr: Iroute[] = [\n    {path: '/', component: App, children:[\n        // 子路由可以不加/\n        {path: 'list', component: lazy(()=> import('pages/List'))},\n        // 不加/*  edit/1 跳转不过来\n        {path: 'edit', component: lazy(()=> import('pages/Edit'))},\n        {path: 'edit/:id', component: lazy(()=> import('pages/Edit'))},\n        {path: 'means', component: lazy(()=> import('pages/Means'))},\n        {path: 'namelist', component: lazy(()=> import('pages/NameList'))},\n    ]},\n    {path: '/login', component: lazy(()=> import('Login'))},\n    {path: '/register', component: lazy(()=> import('Register'))},\n]\n\nconst MyRouter = ()=>(\n    <BrowserRouter basename='/cms_manage/'>\n    {/* 注意位置在Routes外，必须要fallback属性：当在渲染时，使用loading组件 */}\n        <Suspense fallback={<Loading/>}>\n            <Routes>\n                {\n                    routerArr.map((item,index)=>(\n                        item.children ?\n                        // 如果有子路由 一般就2级，最多3级 再套一层就是了\n                        <Route key={index} path={item.path} element={<item.component/>}>\n                            {\n                                item.children.map((item,index)=>(\n                                    <Route key={index} path={item.path} element={<item.component/>}></Route>\n                                ))\n                            }\n                        </Route>\n                        :\n                        // 没有子路由\n                        <Route key={index} path={item.path} element={<item.component/>}></Route>\n                    ))\n                }\n           \n            </Routes>     \n        </Suspense>\n    </BrowserRouter>\n)\nexport default MyRouter;\n\n2.使用时，只需要在对应位置，使用\n<Outlet />\n\n3.在index.ts中\nimport MyRouter from 'router';\nReactDOM.render(\n    <Provider store={store}>\n        <MyRouter />\n    </Provider>,\n    document.getElementById('root')\n)\n")])])]),e("h2",{attrs:{id:"react-router-v6-新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-v6-新特性"}},[t._v("#")]),t._v(" React-Router v6 新特性")]),t._v(" "),e("p",[t._v("https://juejin.cn/post/7033313711947251743")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("React Router 有以下三个不同的包放在npm上\n\n1. react-router: 路由的核心库，提供很多组件和狗子\n\n2. react-router-dom:包括react-router所有，并添加一些专门用于DOM的组件，比如<BrowserRouter>\n\n3.react-router-native 包括react-router所有内容，并添加一些专门为ReactNative的API 如<NativeRouter>\n\n新增多个hook\nuseParams 返回当前参数，根据url读取参数\nuseNavigate 代替useHistory\nuseMatch \nuseOutlet 返回根据路由生成的element\nuseLocation 返回location对象\nuseRoutes 同Routers组件\nuseSearchParams 用于匹配URL中?后面的搜索参数\n\n{* path是相对的，可以省略/  同时/表当前路径 *}\nhttps://juejin.cn/post/7025418839454122015#heading-6  重点\n\n{* 默认exact *}\n\n{*  v6 Route 的 children 是用于嵌套路由,\n嵌套的 parent route 的 path 不用加*\n非嵌套的，分散在子组件的话，要加/* *}\n\n")])])]),e("h2",{attrs:{id:"v6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v6"}},[t._v("#")]),t._v(" v6")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function App() {\n  return (\n    <div className=\"App\">\n        //注册一级路由\n      <BrowserRouter>\n        {/* switch 单一匹配 被Routes代替  路由写法改变*/}\n        <Routes>\n          <Route path='/login' element={<Login/>}> </Route>\n            //路由嵌套时 写在admin中注册子路由要+/*\n          <Route path='//*' element={<Admin/>}> </Route>\n            // 重定向 用*表找不到的路径\n          <Route path=\"*\" element={<Admin />} />\n        </Routes>\n      </BrowserRouter>\n    </div>\n  );\n}\n\n//  在Admin中注册二级路由\n                        <Routes>\n\t\t\t\t\t\tindex 即表示是否是主路由，不能有 children\n\t\t\t\t\t\t//此时 /admin 会自动显示Home组件   虽然我的是/\n\t\t\t\t\t\t<Route index element={<Home />} />\n                            <Route path='home' element={<Home/>}></Route>\n                            <Route path='product/*' element={<Product/>}></Route>  \n\t\t\t\t\t\t//重定向注意加/*\n                             <Route path=\"/*\" element={<Home />} />            \n                        </Routes>\n//在product中注册三级路由\n        <Routes>\n            {/* 注意不要写成/product/detail */}\n            <Route path='/detail' element={<ProductDetail/>}> </Route>\n            <Route path='addupdate' element={<ProductAddUpdate/>}> </Route>\n            {/* /在这里表 /product路径 */}\n            <Route path='/' element={<ProductHome/>}> </Route>\n\t\t\t//重定向注意加/*\n            <Route path=\"/*\" element={<ProductHome />} />\n        </Routes>\n\n\n\n     \n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);