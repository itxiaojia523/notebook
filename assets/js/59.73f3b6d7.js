(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{463:function(t,n,e){"use strict";e.r(n);var a=e(2),s=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"jsx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("在 React 中创建的虚拟元素可以分为两类，DOM 元素（DOM element）\n与组件元素（component element），分别对应着原生 DOM 元素与自定义元素，而 JSX 与创建元\n素的过程有着莫大的关联。\n\n1. DOM 元素\n在需要描述\n一个按钮（button），这用 HTML 语法表示非常简单：\n<button class=\"btn btn-blue\">\n <em>Confirm</em>\n</button>\n其中包括了元素的类型和属性。如果转成 JSON 对象，那么依然包括元素的类型以及属性：\n{\n type: 'button',\n props: {\n className: 'btn btn-blue',\n children: [{\n type: 'em',\n props: {\n children: 'Confirm'\n }\n }]\n }\n} \n这样，我们就可以在 JavaScript 中创建 Virtual DOM 元素了。\n在 React 中，到处都是可以复用的元素，这些元素并不是真实的实例，它只是让 React 告诉\n开发者想要在屏幕上显示什么。我们无法通过方法去调用这些元素，它们只是不可变的描述对象。\n\n2. 组件元素\n当然，我们可以很方便地封装上述 button 元素，得到一种构建按钮的公共方法：\nconst Button = ({ color, text }) => {\n\treturn {\n\t\ttype: 'button',\n\t\tprops: {\n\t\t\tclassName: `btn btn-${color}`,\n\t\t\tchildren: {\n\t\t\t\ttype: 'em',\n\t\t\t\tprops: {\n\t\t\t\tchildren: text,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n} \n自然，当我们要生成 DOM 元素中具体的按钮时，就可以方便地调用 Button({color:'blue',text:'Confirm'}) 来创建。\n仔细思考这个过程可以发现，Button 方法其实也可以作为元素而存在，方法名对应了 DOM\n元素类型，参数对应了 DOM 元素属性，那么它就具备了元素的两大必要条件，这样构建的元素\n就是自定义类型的元素，或称为组件元素。我们用 JSON 结构来描述它：\n{\n type: Button,\n props: {\n color: 'blue',\n children: 'Confirm'\n }\n}\n这也是 React 的核心思想之一。因为有公共的表达方法，我们就可以让元素们彼此嵌套或混\n合。这些层层封装的组件元素，就是所谓的 React 组件，最终我们可以用递归渲染的方式构建出\n完全的 DOM 元素树。\n\n继续封装新的组件元素：\nconst DeleteAccount = () => ({\n type: 'div',\n props: {\n\tchildren: [{\n\t\ttype: 'p',\n\t\tprops: {\n\t\tchildren: 'Are you sure?',\n\t\t},\n\t\t}, {\n\t\ttype: DangerButton,\n\t\tprops: {\n\t\tchildren: 'Confirm',\n\t\t},\n\t\t}, {\n\t\ttype: Button,\n\t\tprops: {\n\t\tcolor: 'blue',\n\t\tchildren: 'Cancel',\n\t\t},\n\t}],\n }\n});\n\n假如我们使用 JSX 语法来重新表达上述\n组件元素，只需这么写：\nconst DeleteAccount = () => (\n <div>\n\t<p>Are you sure?</p>\n\t<DangerButton>Confirm</DangerButton>\n\t<Button color=\"blue\">Cancel</Button>\n </div>\n); \n\nJSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯\nJavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不\n会带来任何副作用，反而会让代码更加直观并易于维护。\n\nReact 官方在早期为 JSX 语法解析开发了一套编译器 JSTransform，目前已经不再维护，现在\n已全部采用 Babel 的 JSX 编译器实现。因为两者在功能上完全重复，而 Babel 作为专门的\nJavaScript 语法编译工具，提供了更为强大的功能，达到了“一处配置，统一运行”的目的。\n\n我们试着将 DeleteAccount 组件通过 Babel 转译成 React 可以执行的代码：\nvar DeleteAccount = function DeleteAccount() {\n return React.createElement(\n\t'div',\n\tnull,\n\tReact.createElement(\n\t'p',\n\tnull,\n\t'Are you sure?'\n\t),\n\tReact.createElement(\n\tDangerButton,\n\tnull,\n\t'Confirm'\n\t),\n\tReact.createElement(\n\tButton,\n\t{ color: 'blue' },\n\t'Cancel'\n\t)\n ); \n }; \n\n 可以看到，除了在创建元素时使用 React.createElement 创建之外，其结构与一直在讲的\nJSON 的结构是一致的。\n\n反过来说，JSX 并不是强制选项，我们可以像上述代码那样直接书写而无须编译，但这实在\n是极其槽糕的编程体验。JSX 的出现为我们省去了这个烦琐过程，使用 JSX 写法的代码更易于阅\n读与开发。事实上，JSX 并不需要花精力学习。只要你熟悉 HTML 标签，大多数功能就都可以\n直接使用了。\n")])])]),n("h2",{attrs:{id:"jsx语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jsx语法"}},[t._v("#")]),t._v(" jsx语法")]),t._v(" "),n("h3",{attrs:{id:"xml-基本语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#xml-基本语法"}},[t._v("#")]),t._v(" XML 基本语法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("使用类 XML 语法的好处是标签可以任意嵌套\nconst List = () => (\n\t<div>\n\t\t<Title>This is title</Title>\n\t\t<ul>\n\t\t\t<li>list item</li>\n\t\t\t<li>list item</li>\n\t\t\t<li>list item</li>\n\t\t</ul>\n\t</div>\n); \n注意:\n1.定义标签时，只允许被一个标签包裹,只有一个根标签\n2.标签一定要闭合\n所有标签（比如 <div></div>、<p></p>）都必须闭合，否则无法编译通\n过。其中 HTML 中自闭合的标签（如 <img>）在 JSX 中也遵循同样规则，自定义标签可\n以根据是否有子组件或文本来决定闭合方式。\n")])])]),n("h3",{attrs:{id:"元素类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#元素类型"}},[t._v("#")]),t._v(" 元素类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('DOM 元素和组件元素\nJSX 里对应规则是 HTML 标签首字母是否为小写字母\n其中小写首字母对应 DOM 元素，而组件元素自然对应大写首字母。\n\n比如 List 组件中的 <div> 标签会生成 DOM 元素，Title 以大写字母开头，会生成组件元素：\nconst Title = (children) => (\n <h3>{children}</h3>\n);\n等到依赖的组件元素中不再出现组件元素，我们就可以将完整的 DOM 树构建出来了。\n\nJSX 还可以通过命名空间的方式使用组件元素，以解决组件相同名称冲突的问题，或是对一\n组组件进行归类。比如，我们想使用 Material UI 组件库中的组件，以 MUI 为包名，可以这么写：\nconst App = () => (\n <MUI.RaisedButton label="Default" />\n);\n在 HTML 标准中，还有一些特殊的标签值得讨论，比如注释和 DOCTYPE 头。\n')])])]),n("h4",{attrs:{id:"注释"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("在 HTML 中，注释写成 \x3c!-- content --\x3e 这样的形式，但在 JSX 中并没有定义注释的转换\n方法。事实上，JSX 还是 JavaScript，依然可以用简单的方法使用注释，唯一要注意的是，在一\n个组件的子元素位置使用注释要用 {} 包起来。示例代码如下：\nconst App = (\n <Nav>\n {/* 节点注释 */}\n <Person\n /* 多行\n 注释 */\n name={window.isLoggedIn ? window.name : ''}\n />\n </Nav>\n);\n但 HTML 中有一类特殊的注释——条件注释，它常用于判断浏览器的版本：\n\x3c!--[if IE]>\n <p>Work in IE browser</p>\n<![endif]--\x3e\n上述方法可以通过使用 JavaScript 判断浏览器版本来替代：\n{\n (!!window.ActiveXObject || 'ActiveXObject' in window) ?\n <p>Work in IE browser</p> : ''\n}\n一般来说，条件注释的使用场景是在 <head> 中判断加载对应的脚本或样式。在服务端渲染\n中，我们还会遇到这样的场景，在 0.14 版本中可以使用 <meta> 标签来实现：\n<meta dangerouslySetInnerHTML={\n_html: `\n \x3c!--[if IE]>\n <script src=\"//example.org/app.js\"><\/script>\n <![endif]--\x3e\n`\n} />\n但在 15.0 版本中这已经不可用。因此，还是建议在 JavaScript 里判断浏览器版本，进行一些\n特有的操作。\n\n\n\n")])])]),n("h4",{attrs:{id:"doctype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#doctype"}},[t._v("#")]),t._v(" DOCTYPE")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("DOCTYPE 头是一个非常特殊的标志，一般会在使用 React 作为服务端渲染时用到。在 HTML\n中，DOCTYPE 是没有闭合的，也就是说我们无法渲染它。\n常见的做法是构造一个保存 HTML 的变量，将 DOCTYPE 与整个 HTML 标签渲染后的结果串\n连起来。第 7 章会详细讲到。\n\n")])])]),n("h3",{attrs:{id:"元素属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#元素属性"}},[t._v("#")]),t._v(" 元素属性")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('元素除了标签之外，另一个组成部分就是标签的属性。\n在 JSX 中，不论是 DOM 元素还是组件元素，它们都有属性。不同的是，DOM 元素的属性\n是标准规范属性，但有两个例外——class 和 for，这是因为在 JavaScript 中这两个单词都是关键\n词。因此，我们这么转换：\n class 属性改为 className；\n for 属性改为 htmlFor。\n而组件元素的属性是完全自定义的属性，也可以理解为实现组件所需要的参数。比如：\nconst Header = ({title, children}) => (\n <h3 title={title}>{children}</h3>\n);\n我们给 Header 组件加了一个 title 属性，那么可以这么调用：\n<Header title="hello world">Hello world</Header>\n当然，我们可以再给 Header 组件加上 color 等属性。可以看到，Header 和 h3 中两个 title 的\n不同之处，一个代表的是自定义标签的属性可以传递，一个是标签自带的属性无法传递。值得注\n意的是，在写自定义属性的时候，都由标准写法改为小驼峰写法。\n此外，还有一些 JSX 特有的属性表达。\n\nBoolean 属性\n省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true。要传 false 时，必须使用属性表\n达式。这常用于表单元素中，比如 disabled、required、checked 和 readOnly 等。\n\n例如，<Checkbox checked={true} /> 可以简写为 <Checkbox checked />，反之 <Checkbox\nchecked={false} /> 就可以省略 checked 属性。\n')])])]),n("h4",{attrs:{id:"展开属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#展开属性"}},[t._v("#")]),t._v(" 展开属性")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("如果事先知道组件需要的全部属性，JSX 可以这样来写：\nconst component = <Component name={name} value={value} />;\n如果你不知道要设置哪些 props，那么现在最好不要设置它：\nconst component = <Component />;\ncomponent.props.name = name;\ncomponent.props.value = value;\n上述这样是反模式，因为 React 不能帮你检查属性类型（propTypes）。这样即使组件的属性\n类型有错误，也不能得到清晰的错误提示。\n这里，可以使用 ES6 rest/spread 特性来提高效率：\nconst data = { name: 'foo', value: 'bar' };\nconst component = <Component name={data.name} value={data.value} />;\n可以写成：\nconst data = { name: 'foo', value: 'bar' };\nconst component = <Component {...data} />; \n")])])]),n("h4",{attrs:{id:"自定义-html-属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义-html-属性"}},[t._v("#")]),t._v(" 自定义 HTML 属性")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('如果在 JSX 中往 DOM 元素中传入自定义属性，React 是不会渲染的：\n<div d="xxx">content</div>\n如果要使用 HTML 自定义属性，要使用 data- 前缀，这与 HTML 标准也是一致的：\n<div data-attr="xxx">content</div>\n然而，在自定义标签中任意的属性都是被支持的：\n<x-my-component custom-attr="foo" />\n以 aria- 开头的网络无障碍属性同样可以正常使用：\n<div aria-hidden={true}></div>\n不论组件是用什么方法来写，我们都需要知道，组件的最终目的是输出虚拟元素，也就是需\n要被渲染到界面的结构。其核心渲染方法，或称为组件输出方法，就是 render 方法。它是 React\n组件生命周期的一部分，也是最核心的函数之一。1\n')])])]),n("h3",{attrs:{id:"javascript-属性表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-属性表达式"}},[t._v("#")]),t._v(" JavaScript 属性表达式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("属性值要使用表达式，只要用 {} 替换 \"\" 即可\n\n// 输入（JSX）：\nconst person = <Person name={window.isLoggedIn ? window.name : ''} />;\n// 输出（JavaScript）：\nconst person = React.createElement(\n Person,\n {name: window.isLoggedIn ? window.name : ''}\n);\n子组件也可以作为表达式使用：\n// 输入（JSX）：\nconst content = <Container>{window.isLoggedIn ? <Nav /> : <Login />}</Container>;\n// 输出（JavaScript）：\nconst content = React.createElement(\n Container,\n null,\n window.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)\n); \n")])])]),n("h3",{attrs:{id:"html-转义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#html-转义"}},[t._v("#")]),t._v(" HTML 转义")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("React 会将所有要显示到 DOM 的字符串转义，防止 XSS。所以，如果 JSX 中含有转义后的\n实体字符，比如 &copy;（©），则最后 DOM 中不会正确显示，因为 React 自动把 &copy; 中的特\n殊字符转义了。有几种解决办法：\n 直接使用 UTF-8 字符 ©；\n 使用对应字符的 Unicode 编码查询编码；\n 使用数组组装 <div>{['cc ', <span>&copy;</span>, ' 2015']}</div>；\n 直接插入原始的 HTML。\n此外，React 提供了 dangerouslySetInnerHTML 属性。正如其名，它的作用就是避免 React 转\n义字符，在确定必要的情况下可以使用它：\n<div dangerouslySetInnerHTML={{__html: 'cc &copy; 2015'}} />\n")])])]),n("h2",{attrs:{id:"jsx语法-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jsx语法-2"}},[t._v("#")]),t._v(" jsx语法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t1.定义虚拟DOM时，不要写引号,不是字符串\n\t2.标签中混入**js表达式**时要用{}\n\t3.样式的类名要用className\n\t4.内联样式写法：style={{key:value}}\n\t\t理解：第一个{} 表示要写js表达式 第二个{}表示要写对象\n\t5.只有一个根标签\n\t6.标签必须闭合\n\t7.标签首字母\n\t\t1) 若小写字母开头，则将标签转为html同名元素，若html中没有对应的同名元素，则报错\n\t\t2) 若大写字母，则识别为组件，若组件没有定义，则报错\n\nex.\n1.创建虚拟DOM\nconst VDOM = (\n\t<div>\n\t\t<h2 className=\"title\" id={myId.toLowerCase()}>\n\t\t\t<span style={{color:'white', fontSize:'29px'}}>{myData.toLowerCase()}</span>\n\t\t</h2>\n\t\t<h2 className=\"title\" id={myId.toLowerCase()}>\n\t\t\t<span style={{color:'white', fontSize:'29px'}}>{myData.toLowerCase()}</span>\n\t\t</h2>\n\t\t<input type=\"text\"/>\n\t\t<Good>123</Good>\n\t</div>\n)\n\n2.渲染虚拟DOM\nReactDOM.render(VDOM,document.getElementById('test'))\n")])])]),n("h1",{attrs:{id:"区分js语句和表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#区分js语句和表达式"}},[t._v("#")]),t._v(" 区分js语句和表达式")]),t._v(" "),n("p",[t._v("关键点：一个"),n("strong",[t._v("表达式")]),t._v("会产生一个"),n("strong",[t._v("值")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("以下是表达式：\n\ta\n\ta+b\n\tdemo(1) //函数有返回值\n\tarr.map() //返回新的数组\n\tfunction test(){}\n\t\n以下是语句\n\tif\n\tfor\nswitch\n\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);