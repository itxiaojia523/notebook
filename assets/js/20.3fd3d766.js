(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{424:function(t,n,o){"use strict";o.r(n);var e=o(2),r=Object(e.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"原型与原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型与原型链"}},[this._v("#")]),this._v(" 原型与原型链")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("变量找作用域链，属性找原型链\nfunction Person() {}\nPerson.prototype.name = 'Kevin';\nvar person = new Person();\nperson.name = 'Daisy';\nconsole.log(person.name) // Daisy\n对象的属性顺着原型链找，自身开始\n\ndelete person.name;\nconsole.log(person.name) // Kevin  自身没有找到了原型里的Kevin\n\n\n\n蓝色的这条线由相互关联的原型组成的链状结构就是原型链\n\n①prototype是函数才会有的属性\n②JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型\n它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n③\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以\nperson.constructor === Person.prototype.constructor\n\n每一个对象都会从原型‘继承’属性\n继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些\n\n④原型对象就是通过 Object 构造函数生成\n\n⑤null 表示“没有对象”，即该处不应该有值。\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n所以查找属性的时候查到 Object.prototype 就可以停止查找了\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);