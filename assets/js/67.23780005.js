(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{470:function(t,e,n){"use strict";n.r(e);var o=n(2),a=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"hooks到底是什么呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks到底是什么呢"}},[t._v("#")]),t._v(" hooks到底是什么呢")]),t._v(" "),e("p",[t._v("钩子编程（hooking) 是计算机程序设计术语, 通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。")]),t._v(" "),e("p",[t._v("简单理解为：在特定的时机，执行的回调")]),t._v(" "),e("h2",{attrs:{id:"react-hooks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[t._v("#")]),t._v(" React Hooks")]),t._v(" "),e("p",[t._v("1.只能在React的"),e("strong",[t._v("函数组件FC")]),t._v("中使用")]),t._v(" "),e("p",[t._v("2.只能在"),e("strong",[t._v("函数最外层")]),t._v("调用")]),t._v(" "),e("h2",{attrs:{id:"usestate-initialstate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usestate-initialstate"}},[t._v("#")]),t._v(" useState(initialState)")]),t._v(" "),e("p",[t._v("state概念参考: "),e("RouterLink",{attrs:{to:"/front/react/core.html"}},[t._v("core")])],1),t._v(" "),e("p",[t._v("(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("注意事项\n1.useState 是一个 Hook，因此你只能在 组件的顶层 或自己的 Hook 中调用它。\n你不能在循环或条件语句中调用它。如果你需要这样做，请提取一个新组件并将状态移入其中。\n\n2.在严格模式中，React 将 两次调用初始化函数，以 帮你找到意外的不纯性。这只是开发时的行为，不影响生产。\n如果你的初始化函数是纯函数（本该是这样），就不应影响该行为。其中一个调用的结果将被忽略。\n")])])]),e("p",[t._v("(2). 语法:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    const [xxx, setXxx] = React.useState(initialState)\n    const [xxx, setXxx] = useState<dataType>(initialState) //ts\n    使用 数组解构 来命名状态变量，例如 [something, setSomething]。\n\n    参数:\n    initialState 初始化的值。可以是任何类型，但对于函数有特殊的行为。在初始渲染后，此参数将被忽略。\n\n    ---\n    如是函数，应该是纯函数，不该接收任意参数，并且应该返回一个指\n    const [todos, setTodos] = useState(createInitialTodos);\n    注意：不要调用函数\n    仍然在每次渲染时调用此函数。如果它创建大数组或执行昂贵的计算，这可能会浪费资源。\n    const [todos, setTodos] = useState(createInitialTodos());\n    ---\n\n    返回值：返回一个由两个值组成的数组\n    1.当前的 state。在首次渲染时，它将与你传递的 initialState 相匹配。\n    2.set 函数，它可以让你将 state 更新为不同的值并触发重新渲染。\n\n    setXxx()2种写法:\n\n    //新值不依赖旧值计算\n    setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n    //新值依赖旧值计算\n    setXxx(preState => newValue): 参数为函数, 接收preState, 返回新的state, 内部用其覆盖原来的状态值\n\n    setState\n    根据先前的 state 更新 state \n    假设 age 为 42，这个处理函数三次调用 setAge(age + 1)：\n    function handleClick() {\n      setAge(age + 1); // setAge(42 + 1)\n      setAge(age + 1); // setAge(42 + 1)\n      setAge(age + 1); // setAge(42 + 1)\n    }\n    然而，点击一次后，age 将只会变为 43 而不是 45！\n    这是因为调用 set 函数 不会更新 已经运行代码中的 age 状态变量。因此，每个 setAge(age + 1) 调用变成了 setAge(43)。\n\n    为了解决这个问题，你可以向 setAge 传递一个 更新函数，而不是下一个状态：\n    function handleClick() {\n      setAge(a => a + 1); // setAge(42 => 43)\n      setAge(a => a + 1); // setAge(43 => 44)\n      setAge(a => a + 1); // setAge(44 => 45)\n    }\n\n    注意事项\n    1.set 函数 仅更新 下一次 渲染的状态变量。如果在调用 set 函数后读取状态变量，则 仍会得到在调用之前显示在屏幕上的旧值。\n    2.React 会 批量处理状态更新。它会在所有 事件处理函数运行 并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在某些罕见情况下，你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 flushSync。\n\n    存储前一次渲染的信息\n\n    然而，在极少数情况下，你可能希望在响应渲染时调整状态——例如，当 props 改变时，你可能希望改变状态变量(在大多数情况下，你不需要这样做)。\n\n    如果你需要的值可以完全从当前 props 或其他 state 中计算出来，那么 完全可以移除那些多余的状态。如果你担心重新计算的频率过高，可以使用 useMemo Hook 来帮助优化。\n    如果你想重置整个组件树的状态，可以向组件传递一个不同的 key。\n    如果可以的话，在事件处理函数中更新所有相关状态。\n\n\n    是否总是优先使用更新函数\n    在大多数情况下，这两种方法没有区别。React 始终确保对于有意的用户操作，如单击，age 状态变量将在下一次单击之前被更新。这意味着单击事件处理函数在事件处理开始没有得到“过时” age 的风险。\n\n    但是，如果在同一事件中进行多个更新，则更新函数可能会有帮助。如果访问状态变量本身不方便（在优化重新渲染时可能会遇到这种情况），它们也很有用。\n\n    如果比起轻微的冗余你更喜欢语法的一致性，你正设置的状态又是根据先前的状态计算出来的，那么总是编写一个更新函数是合理的。如果它是从某个其他状态变量的先前状态计算出的，则你可能希望将它们结合成一个对象然后 使用 reducer。\n\n    更新状态中的对象和数组\n    // 🚩 不要像下面这样改变一个对象：\n    form.firstName = 'Taylor';\n\n    可以通过创建一个新对象来替换整个对象：\n    // ✅ 使用新对象替换 state\n    setForm({\n      ...form,\n      firstName: 'Taylor'\n    });\n\n    使用 key 重置状态 \n    在 渲染列表 时，你经常会遇到 key 属性。然而，它还有另外一个用途。\n\n    你可以 通过向组件传递不同的 key 来重置组件的状态。在这个例子中，重置按钮改变 version 状态变量，我们将它作为一个 key 传递给 Form 组件。当 key 改变时，React 会从头开始重新创建 Form 组件（以及它的所有子组件），所以它的状态被重置了。\n\n    export default function App() {\n      const [version, setVersion] = useState(0);\n\n      function handleReset() {\n        setVersion(version + 1);\n      }\n\n      return (\n        <>\n          <button onClick={handleReset}>Reset</button>\n          <Form key={version} />\n        </>\n      );\n    }\n")])])]),e("h2",{attrs:{id:"useeffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[t._v("#")]),t._v(" useEffect")]),t._v(" "),e("p",[t._v("(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)")]),t._v(" "),e("p",[t._v("(2). React中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实DOM")]),t._v(" "),e("p",[t._v("(3). 语法和说明:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    1.空数组时，可以看作componentDidMount() \n    useEffect(() => { \n      // 在此可以执行任何带副作用操作\n    }, []) \n\n    2.内部函数的return也是一个函数，可以看作componentWillUnmount() \n    useEffect(() => { \n      // 在此可以执行任何带副作用操作\n      return () => { // 在组件卸载前执行\n        // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n      }\n    }, []) \n\n    3.根据state值，当这些值发生更新时，才会执行componentDidUpdate()\n    useEffect(() => { \n      // 在此可以执行任何带副作用操作\n    }, [stateValue]) \n")])])]),e("h2",{attrs:{id:"uselayouteffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uselayouteffect"}},[t._v("#")]),t._v(" useLayoutEffect")]),t._v(" "),e("p",[e("strong",[t._v("可能会影响性能。尽可能使用 useEffect。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  作用：在浏览器重新绘制屏幕前计算布局\n  注意：\n  1.Effect 只在客户端上运行，在服务端渲染中不会运行。\n  2.useLayoutEffect 内部的代码和所有计划的状态更新阻塞了浏览器重新绘制屏幕。如果过度使用，这会使你的应用程序变慢。如果可能的话，尽量选择 useEffect。\n\n  大多数组件只返回一些 JSX，然后浏览器计算他们的 布局（位置和大小）并重新绘制屏幕。\n  不需要依靠它们在屏幕上的位置和大小来决定渲染什么。\n\n  有时候，这还不够。想象一下悬停时出现在某个元素旁边的 tooltip。如果有足够的空间，tooltip 应该出现在元素的上方，但是如果不合适，它应该出现在下面。为了让 tooltip 渲染在最终正确的位置，你需要知道它的高度（即它是否适合放在顶部）。\n\n  要做到这一点，你需要分两步渲染：\n\n  1.将 tooltip 渲染到任何地方（即使位置不对）。\n  2.测量它的高度并决定放置 tooltip 的位置。\n  3.把 tooltip 渲染放在正确的位置。\n  所有这些都需要在浏览器重新绘制屏幕之前完成。你不希望用户看到 tooltip 在移动。调用 useLayoutEffect 在浏览器重新绘制屏幕之前执行布局测量：\n\n  function Tooltip() {\n  const ref = useRef(null);\n  const [tooltipHeight, setTooltipHeight] = useState(0); // 你还不知道真正的高度\n\n  useLayoutEffect(() => {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height); // 现在重新渲染，你知道了真实的高度\n  }, []);\n\n  // ... 在下方的渲染逻辑中使用 tooltipHeight ...\n\n  下面是这如何一步步工作的：\n\n  1.Tooltip 使用初始值 tooltipHeight = 0 进行渲染（因此 tooltip 可能被错误地放置）。\n  2.React 将它放在 DOM 中，然后运行 useLayoutEffect 中的代码。\n  3.useLayoutEffect 测量 了 tooltip 内容的高度，并立即触发重新渲染。\n  4.使用实际的 tooltipHeight 再次渲染 Tooltip（这样 tooltip 的位置就正确了）。\n  5.React 在 DOM 中对它进行更新，浏览器最终显示出 tooltip。\n\n\n  TooltipContainer.js\n  export default function TooltipContainer({ children, x, y, contentRef }) {\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        pointerEvents: 'none',\n        left: 0,\n        top: 0,\n        transform: `translate3d(${x}px, ${y}px, 0)`\n      }}\n    >\n      <div ref={contentRef} className=\"tooltip\">\n        {children}\n      </div>\n    </div>\n  );\n}\n\nTooltip.js\nimport { useRef, useLayoutEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n  const ref = useRef(null);\n  const [tooltipHeight, setTooltipHeight] = useState(0);\n\n  useLayoutEffect(() => {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height);\n    console.log('Measured tooltip height: ' + height);\n  }, []);\n\n  let tooltipX = 0;\n  let tooltipY = 0;\n  if (targetRect !== null) {\n    tooltipX = targetRect.left;\n    tooltipY = targetRect.top - tooltipHeight;\n    if (tooltipY < 0) {\n      // 它不适合上方，因此把它放在下面。\n      tooltipY = targetRect.bottom;\n    }\n  }\n\n  return createPortal(\n    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n      {children}\n    </TooltipContainer>,\n    document.body\n  );\n}\n\nButtonWithTooltip.js\nimport { useState, useRef } from 'react';\nimport Tooltip from './Tooltip.js';\n\nexport default function ButtonWithTooltip({ tooltipContent, ...rest }) {\n  const [targetRect, setTargetRect] = useState(null);\n  const buttonRef = useRef(null);\n  return (\n    <>\n      <button\n        {...rest}\n        ref={buttonRef}\n        onPointerEnter={() => {\n          const rect = buttonRef.current.getBoundingClientRect();\n          setTargetRect({\n            left: rect.left,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n          });\n        }}\n        onPointerLeave={() => {\n          setTargetRect(null);\n        }}\n      />\n      {targetRect !== null && (\n        <Tooltip targetRect={targetRect}>\n          {tooltipContent}\n        </Tooltip>\n      )\n    }\n    </>\n  );\n}\n\nApp.js\nimport ButtonWithTooltip from './ButtonWithTooltip.js';\n\nexport default function App() {\n  return (\n    <div>\n      <ButtonWithTooltip\n        tooltipContent={\n          <div>\n            This tooltip does not fit above the button.\n            <br />\n            This is why it's displayed below instead!\n          </div>\n        }\n      >\n        Hover over me (tooltip above)\n      </ButtonWithTooltip>\n      <div style={{ height: 50 }} />\n      <ButtonWithTooltip\n        tooltipContent={\n          <div>This tooltip fits above the button</div>\n        }\n      >\n        Hover over me (tooltip below)\n      </ButtonWithTooltip>\n      <div style={{ height: 50 }} />\n      <ButtonWithTooltip\n        tooltipContent={\n          <div>This tooltip fits above the button</div>\n        }\n      >\n        Hover over me (tooltip below)\n      </ButtonWithTooltip>\n    </div>\n  );\n}\n\n\n\n}\n")])])]),e("h2",{attrs:{id:"useref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[t._v("#")]),t._v(" useRef")]),t._v(" "),e("p",[t._v("它能让你引用一个不需要渲染的值。")]),t._v(" "),e("p",[t._v("组件更新，ref保持前值")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("作用：\n获取dom节点，代替id\n清理计时器\n\n(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refContainer = useRef()\n(3). 作用:保存标签对象,功能与React.createRef()一样\n(4). 类式组件可以看作DOM节点可以直接用ref  函数式不行\n\n给input加事件，想要input的数据，此时可以不用ref，直接通过event对象\n\n注意事项 \n你可以修改 ref.current 属性。与 state 不同，它是可变的。然而，如果它持有一个用于渲染的对象（例如，你的 state 的一部分），那么你就不应该修改这个对象。\n当你改变 ref.current 属性时，React 不会重新渲染你的组件。React 不知道你何时改变它，因为 ref 是一个普通的 JavaScript 对象。\n除了 初始化 外不要在渲染期间写入 或者读取 ref.current。这会使你的组件的行为不可预测。\n\n如何避免在初始化 useRef 之后进行 null 的类型检查\n\nfunction Video() {\n  const playerRef = useRef(null);\n\n  function getPlayer() {\n    if (playerRef.current !== null) {\n      return playerRef.current;\n    }\n    const player = new VideoPlayer();\n    playerRef.current = player;\n    return player;\n  }\n  }\n\n\n")])])]),e("p",[t._v("传递 ref 到你自己的组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const inputRef = useRef(null);\nreturn <MyInput ref={inputRef} />;\n\n1. 找到你想获得 ref 的组件 将其包装在 forwardRef 里\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(({ value, onChange }, ref) => {\n  return (\n    <input\n      value={value}\n      onChange={onChange}\n      ref={ref}\n    />\n  );\n});\n\nexport default MyInput;\n\n")])])]),e("h2",{attrs:{id:"usememo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[t._v("#")]),t._v(" useMemo")]),t._v(" "),e("p",[t._v("它在每次重新渲染的时候能够缓存计算的结果")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const cachedValue = useMemo(calculateValue, dependencies)\ncalculateValue 要缓存计算值的函数\nReact 将会在首次渲染时调用该函数；在之后的渲染中，如果 dependencies 没有发生变化，React 将直接返回相同值\n\ndependencies 响应式变量包括 props、state 和所有你直接在组件中定义的变量和函数\n")])])]),e("p",[t._v("用法 :跳过代价昂贵的重新计算")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("如何衡量计算过程的开销是否昂贵？ \n一般来说，除非要创建或循环遍历数千个对象，否则开销可能并不大。如果你想获得更详细的信息，可以在控制台来测量花费这上面的时间：\nconsole.time('filter array');\nconst visibleTodos = filterTodos(todos, tab);\nconsole.timeEnd('filter array');\n如果全部记录的时间加起来很长（1ms 或者更多），那么记忆此计算结果是有意义的\n你的开发设备可能比用户的设备性能更强大，因此最好人为降低当前浏览器性能来测试\n\n\n\n")])])]),e("p",[t._v("何时使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("如果你的应用程序类似于此站点，并且大多数交互都很粗糙（例如替换页面或整个章节），则通常不需要使用记忆化。反之，如果你的应用程序更像是绘图编辑器，并且大多数交互都是颗粒状的（如移动形状），那么你可能会发现记忆化非常有用。\n\n一些团队选择不考虑具体情况，尽可能多地使用 useMemo。不过这种做法会降低代码可读性。此外，并不是所有 useMemo 的使用都是有效的：一个“永远是新的”的单一值就足以破坏整个组件的记忆化效果\n\n\n在实践中，你可以通过遵循一些原则来避免 useMemo 的滥用：\n\n1.当一个组件在视觉上包裹其他组件时，让它 将 JSX 作为子组件传递。这样，当包装器组件更新自己的 state 时，React 知道它的子组件不需要重新渲染。\n2.首选本地 state，非必要不进行 状态提升。例如，不要保持像表单、组件是否悬停在组件树顶部这样的瞬时状态。\n3.保持你的 渲染逻辑纯粹。如果重新渲染组件会导致一些问题或产生一些明显的视觉错误，那么它就是组件中的错误！修复错误而不是使用记忆化。\n4.避免 不必要地更新 state 的 Effect。React 应用程序中的大多数性能问题都是由 Effect 创造的更新链引起的，这些更新链导致组件反复重新渲染。\n5.尽力 从 Effect 中移除不必要的依赖项。例如, 相比于记忆化，在 Effect 内部或组件外部移动某些对象或函数通常更简单。\n\n如果某个特定的交互仍然感觉滞后，使用 React 开发者工具分析器 查看哪些组件将从记忆化中获益最多，并在需要的地方添加记忆化。这些原则使你的组件更易于调试和理解，因此在任何情况下都应该遵循它们。从长远来看，我们正在研究 自动进行粒度记忆 以一劳永逸地解决这个问题。\n\n\n可以将 <List /> JSX 节点本身包裹在 useMemo 中，而不是将 List 包裹在 memo 中：\nexport default function TodoList({ todos, tab, theme }) {\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);\n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  );\n}\n")])])]),e("h2",{attrs:{id:"usecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),e("p",[t._v("目的："),e("strong",[t._v("避免无效更新")]),t._v("；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的")]),t._v(" "),e("p",[t._v("使用\n当父给子传函数时\n搭配useMemo")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  const addItem = useCallback((value)=>{\n  },[]) //[]里存放，当哪些数据更新时，这个函数也更新\n")])])]),e("h2",{attrs:{id:"usehistory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usehistory"}},[t._v("#")]),t._v(" useHistory")]),t._v(" "),e("p",[t._v("注意：useNavigate代替了useHistory")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { useLocation } from \"react-router-dom\";\nlet location = useLocation();\nconst path = location.pathname\n\n// v5\nimport { useHistory } from 'react-router-dom';\n\nfunction MyButton() {\n  let history = useHistory();\n  function handleClick() {\n    history.push('/home');\n  };\n  return <button onClick={handleClick}>Submit</button>;\n};\n\n// v6\nimport { useNavigate } from 'react-router-dom';\n\nfunction MyButton() {\n  let navigate = useNavigate();\n  function handleClick() {\n    navigate('/home');\n  };\n  return <button onClick={handleClick}>Submit</button>;\n};\nhistory的用法也将被替换成：\n\n// v5\nhistory.push('/home');\nhistory.replace('/home');\n\n// v6\nnavigate('/home');\nnavigate('/home', {replace: true});\n\n//得到当前的路径\nlet location = useLocation();\nlet path = location.pathname\n\nJS路由跳转 useNavigate 代替 useHistory\nimport { useNavigate } from 'react-router-dom';\nlet navigate = useNavigate();\n// 跳转到后台，不需要回退\n\t navigate('/',{replace: true，state })\nnavigate(-1) //回退 \n\n取state\n    const location = useLocation();\n\t传过来的时候 state={product} 但是解构不出来 不是一个对象\n    const product = location.state\n \n")])])]),e("h2",{attrs:{id:"react-router-v6-新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-v6-新特性"}},[t._v("#")]),t._v(" React-Router v6 新特性")]),t._v(" "),e("p",[t._v("https://juejin.cn/post/7033313711947251743")]),t._v(" "),e("h2",{attrs:{id:"路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),e("p",[t._v("useReducer-useContext\n在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数")]),t._v(" "),e("p",[t._v("来自 "),e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("const [state, dispatch] = useReducer(reducer, initialArg, init);")]),t._v(" "),e("p",[t._v("来自 "),e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"react实现拖拽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react实现拖拽"}},[t._v("#")]),t._v(" react实现拖拽")]),t._v(" "),e("p",[t._v("npm install react-dnd react-dnd-html5-backend")]),t._v(" "),e("p",[t._v("https://react-dnd.github.io/react-dnd/about")])])}),[],!1,null,null,null);e.default=a.exports}}]);